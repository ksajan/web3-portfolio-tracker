var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/error.ts
var YAMLError = class extends Error {
  constructor(message = "(unknown reason)", mark = "") {
    super(`${message} ${mark}`);
    this.mark = mark;
    this.name = this.constructor.name;
  }
  toString(_compact) {
    return `${this.name}: ${this.message} ${this.mark}`;
  }
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/utils.ts
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function repeat(str2, count) {
  let result = "";
  for (let cycle = 0; cycle < count; cycle++) {
    result += str2;
  }
  return result;
}
function isNegativeZero(i) {
  return i === 0 && Number.NEGATIVE_INFINITY === 1 / i;
}

// deno:https://deno.land/std@0.147.0/encoding/_yaml/mark.ts
var Mark = class {
  constructor(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  getSnippet(indent = 4, maxLength = 75) {
    if (!this.buffer)
      return null;
    let head = "";
    let start = this.position;
    while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    let tail = "";
    let end = this.position;
    while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    const snippet = this.buffer.slice(start, end);
    return `${repeat(" ", indent)}${head}${snippet}${tail}
${repeat(" ", indent + this.position - start + head.length)}^`;
  }
  toString(compact) {
    let snippet, where = "";
    if (this.name) {
      where += `in "${this.name}" `;
    }
    where += `at line ${this.line + 1}, column ${this.column + 1}`;
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += `:
${snippet}`;
      }
    }
    return where;
  }
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema.ts
function compileList(schema, name, result) {
  const exclude = [];
  for (const includedSchema of schema.include) {
    result = compileList(includedSchema, name, result);
  }
  for (const currentType of schema[name]) {
    for (let previousIndex = 0; previousIndex < result.length; previousIndex++) {
      const previousType = result[previousIndex];
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    }
    result.push(currentType);
  }
  return result.filter((_type, index) => !exclude.includes(index));
}
function compileMap(...typesList) {
  const result = {
    fallback: {},
    mapping: {},
    scalar: {},
    sequence: {}
  };
  for (const types of typesList) {
    for (const type of types) {
      if (type.kind !== null) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
    }
  }
  return result;
}
var Schema = class {
  constructor(definition) {
    this.explicit = definition.explicit || [];
    this.implicit = definition.implicit || [];
    this.include = definition.include || [];
    for (const type of this.implicit) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLError("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    }
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  extend(definition) {
    return new Schema({
      implicit: [
        .../* @__PURE__ */ new Set([...this.implicit, ...(definition == null ? void 0 : definition.implicit) ?? []])
      ],
      explicit: [
        .../* @__PURE__ */ new Set([...this.explicit, ...(definition == null ? void 0 : definition.explicit) ?? []])
      ],
      include: [.../* @__PURE__ */ new Set([...this.include, ...(definition == null ? void 0 : definition.include) ?? []])]
    });
  }
  static create() {
  }
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type.ts
var DEFAULT_RESOLVE = () => true;
var DEFAULT_CONSTRUCT = (data) => data;
function checkTagFormat(tag) {
  return tag;
}
var Type = class {
  constructor(tag, options) {
    this.kind = null;
    this.resolve = () => true;
    this.construct = (data) => data;
    this.tag = checkTagFormat(tag);
    if (options) {
      this.kind = options.kind;
      this.resolve = options.resolve || DEFAULT_RESOLVE;
      this.construct = options.construct || DEFAULT_CONSTRUCT;
      this.instanceOf = options.instanceOf;
      this.predicate = options.predicate;
      this.represent = options.represent;
      this.defaultStyle = options.defaultStyle;
      this.styleAliases = options.styleAliases;
    }
  }
};

// deno:https://deno.land/std@0.147.0/_util/assert.ts
var DenoStdInternalError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError(msg);
  }
}

// deno:https://deno.land/std@0.147.0/bytes/bytes_list.ts
var _len, _chunks;
var BytesList = class {
  constructor() {
    __privateAdd(this, _len, 0);
    __privateAdd(this, _chunks, []);
  }
  size() {
    return __privateGet(this, _len);
  }
  add(value, start = 0, end = value.byteLength) {
    if (value.byteLength === 0 || end - start === 0) {
      return;
    }
    checkRange(start, end, value.byteLength);
    __privateGet(this, _chunks).push({
      value,
      end,
      start,
      offset: __privateGet(this, _len)
    });
    __privateSet(this, _len, __privateGet(this, _len) + (end - start));
  }
  shift(n) {
    if (n === 0) {
      return;
    }
    if (__privateGet(this, _len) <= n) {
      __privateSet(this, _chunks, []);
      __privateSet(this, _len, 0);
      return;
    }
    const idx = this.getChunkIndex(n);
    __privateGet(this, _chunks).splice(0, idx);
    const [chunk] = __privateGet(this, _chunks);
    if (chunk) {
      const diff2 = n - chunk.offset;
      chunk.start += diff2;
    }
    let offset = 0;
    for (const chunk2 of __privateGet(this, _chunks)) {
      chunk2.offset = offset;
      offset += chunk2.end - chunk2.start;
    }
    __privateSet(this, _len, offset);
  }
  getChunkIndex(pos) {
    let max = __privateGet(this, _chunks).length;
    let min = 0;
    while (true) {
      const i = min + Math.floor((max - min) / 2);
      if (i < 0 || __privateGet(this, _chunks).length <= i) {
        return -1;
      }
      const { offset, start, end } = __privateGet(this, _chunks)[i];
      const len = end - start;
      if (offset <= pos && pos < offset + len) {
        return i;
      } else if (offset + len <= pos) {
        min = i + 1;
      } else {
        max = i - 1;
      }
    }
  }
  get(i) {
    if (i < 0 || __privateGet(this, _len) <= i) {
      throw new Error("out of range");
    }
    const idx = this.getChunkIndex(i);
    const { value, offset, start } = __privateGet(this, _chunks)[idx];
    return value[start + i - offset];
  }
  *iterator(start = 0) {
    const startIdx = this.getChunkIndex(start);
    if (startIdx < 0)
      return;
    const first = __privateGet(this, _chunks)[startIdx];
    let firstOffset = start - first.offset;
    for (let i = startIdx; i < __privateGet(this, _chunks).length; i++) {
      const chunk = __privateGet(this, _chunks)[i];
      for (let j = chunk.start + firstOffset; j < chunk.end; j++) {
        yield chunk.value[j];
      }
      firstOffset = 0;
    }
  }
  slice(start, end = __privateGet(this, _len)) {
    if (end === start) {
      return new Uint8Array();
    }
    checkRange(start, end, __privateGet(this, _len));
    const result = new Uint8Array(end - start);
    const startIdx = this.getChunkIndex(start);
    const endIdx = this.getChunkIndex(end - 1);
    let written = 0;
    for (let i = startIdx; i < endIdx; i++) {
      const chunk = __privateGet(this, _chunks)[i];
      const len = chunk.end - chunk.start;
      result.set(chunk.value.subarray(chunk.start, chunk.end), written);
      written += len;
    }
    const last = __privateGet(this, _chunks)[endIdx];
    const rest = end - start - written;
    result.set(last.value.subarray(last.start, last.start + rest), written);
    return result;
  }
  concat() {
    const result = new Uint8Array(__privateGet(this, _len));
    let sum = 0;
    for (const { value, start, end } of __privateGet(this, _chunks)) {
      result.set(value.subarray(start, end), sum);
      sum += end - start;
    }
    return result;
  }
};
_len = new WeakMap();
_chunks = new WeakMap();
function checkRange(start, end, len) {
  if (start < 0 || len < start || end < 0 || len < end || end < start) {
    throw new Error("invalid range");
  }
}

// deno:https://deno.land/std@0.147.0/bytes/mod.ts
function copy(src, dst, off = 0) {
  off = Math.max(0, Math.min(off, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - off;
  if (src.byteLength > dstBytesAvailable) {
    src = src.subarray(0, dstBytesAvailable);
  }
  dst.set(src, off);
  return src.byteLength;
}

// deno:https://deno.land/std@0.147.0/io/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;
var _buf, _off, _tryGrowByReslice, tryGrowByReslice_fn, _reslice, reslice_fn, _grow, grow_fn;
var Buffer2 = class {
  constructor(ab) {
    __privateAdd(this, _tryGrowByReslice);
    __privateAdd(this, _reslice);
    __privateAdd(this, _grow);
    __privateAdd(this, _buf, void 0);
    __privateAdd(this, _off, 0);
    __privateSet(this, _buf, ab === void 0 ? new Uint8Array(0) : new Uint8Array(ab));
  }
  bytes(options = { copy: true }) {
    if (options.copy === false)
      return __privateGet(this, _buf).subarray(__privateGet(this, _off));
    return __privateGet(this, _buf).slice(__privateGet(this, _off));
  }
  empty() {
    return __privateGet(this, _buf).byteLength <= __privateGet(this, _off);
  }
  get length() {
    return __privateGet(this, _buf).byteLength - __privateGet(this, _off);
  }
  get capacity() {
    return __privateGet(this, _buf).buffer.byteLength;
  }
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw Error("bytes.Buffer: truncation out of range");
    }
    __privateMethod(this, _reslice, reslice_fn).call(this, __privateGet(this, _off) + n);
  }
  reset() {
    __privateMethod(this, _reslice, reslice_fn).call(this, 0);
    __privateSet(this, _off, 0);
  }
  readSync(p) {
    if (this.empty()) {
      this.reset();
      if (p.byteLength === 0) {
        return 0;
      }
      return null;
    }
    const nread = copy(__privateGet(this, _buf).subarray(__privateGet(this, _off)), p);
    __privateSet(this, _off, __privateGet(this, _off) + nread);
    return nread;
  }
  read(p) {
    const rr = this.readSync(p);
    return Promise.resolve(rr);
  }
  writeSync(p) {
    const m = __privateMethod(this, _grow, grow_fn).call(this, p.byteLength);
    return copy(p, __privateGet(this, _buf), m);
  }
  write(p) {
    const n = this.writeSync(p);
    return Promise.resolve(n);
  }
  grow(n) {
    if (n < 0) {
      throw Error("Buffer.grow: negative count");
    }
    const m = __privateMethod(this, _grow, grow_fn).call(this, n);
    __privateMethod(this, _reslice, reslice_fn).call(this, m);
  }
  async readFrom(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf = shouldGrow ? tmp : new Uint8Array(__privateGet(this, _buf).buffer, this.length);
      const nread = await r.read(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        __privateMethod(this, _reslice, reslice_fn).call(this, this.length + nread);
      n += nread;
    }
  }
  readFromSync(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf = shouldGrow ? tmp : new Uint8Array(__privateGet(this, _buf).buffer, this.length);
      const nread = r.readSync(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        __privateMethod(this, _reslice, reslice_fn).call(this, this.length + nread);
      n += nread;
    }
  }
};
_buf = new WeakMap();
_off = new WeakMap();
_tryGrowByReslice = new WeakSet();
tryGrowByReslice_fn = function(n) {
  const l = __privateGet(this, _buf).byteLength;
  if (n <= this.capacity - l) {
    __privateMethod(this, _reslice, reslice_fn).call(this, l + n);
    return l;
  }
  return -1;
};
_reslice = new WeakSet();
reslice_fn = function(len) {
  assert(len <= __privateGet(this, _buf).buffer.byteLength);
  __privateSet(this, _buf, new Uint8Array(__privateGet(this, _buf).buffer, 0, len));
};
_grow = new WeakSet();
grow_fn = function(n) {
  const m = this.length;
  if (m === 0 && __privateGet(this, _off) !== 0) {
    this.reset();
  }
  const i = __privateMethod(this, _tryGrowByReslice, tryGrowByReslice_fn).call(this, n);
  if (i >= 0) {
    return i;
  }
  const c = this.capacity;
  if (n <= Math.floor(c / 2) - m) {
    copy(__privateGet(this, _buf).subarray(__privateGet(this, _off)), __privateGet(this, _buf));
  } else if (c + n > MAX_SIZE) {
    throw new Error("The buffer cannot be grown beyond the maximum size.");
  } else {
    const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
    copy(__privateGet(this, _buf).subarray(__privateGet(this, _off)), buf);
    __privateSet(this, _buf, buf);
  }
  __privateSet(this, _off, 0);
  __privateMethod(this, _reslice, reslice_fn).call(this, Math.min(m + n, MAX_SIZE));
  return m;
};
var DEFAULT_BUF_SIZE = 4096;
var MIN_BUF_SIZE = 16;
var MAX_CONSECUTIVE_EMPTY_READS = 100;
var CR = "\r".charCodeAt(0);
var LF = "\n".charCodeAt(0);
var BufferFullError = class extends Error {
  constructor(partial) {
    super("Buffer full");
    this.partial = partial;
    this.name = "BufferFullError";
  }
};
var PartialReadError = class extends Error {
  constructor() {
    super("Encountered UnexpectedEof, data only partially read");
    this.name = "PartialReadError";
  }
};
var _buf2, _rd, _r, _w, _eof, _fill, _reset;
var _BufReader = class {
  constructor(rd, size = DEFAULT_BUF_SIZE) {
    __privateAdd(this, _buf2, void 0);
    __privateAdd(this, _rd, void 0);
    __privateAdd(this, _r, 0);
    __privateAdd(this, _w, 0);
    __privateAdd(this, _eof, false);
    __privateAdd(this, _fill, async () => {
      if (__privateGet(this, _r) > 0) {
        __privateGet(this, _buf2).copyWithin(0, __privateGet(this, _r), __privateGet(this, _w));
        __privateSet(this, _w, __privateGet(this, _w) - __privateGet(this, _r));
        __privateSet(this, _r, 0);
      }
      if (__privateGet(this, _w) >= __privateGet(this, _buf2).byteLength) {
        throw Error("bufio: tried to fill full buffer");
      }
      for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
        const rr = await __privateGet(this, _rd).read(__privateGet(this, _buf2).subarray(__privateGet(this, _w)));
        if (rr === null) {
          __privateSet(this, _eof, true);
          return;
        }
        assert(rr >= 0, "negative read");
        __privateSet(this, _w, __privateGet(this, _w) + rr);
        if (rr > 0) {
          return;
        }
      }
      throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
    });
    __privateAdd(this, _reset, (buf, rd) => {
      __privateSet(this, _buf2, buf);
      __privateSet(this, _rd, rd);
      __privateSet(this, _eof, false);
    });
    if (size < MIN_BUF_SIZE) {
      size = MIN_BUF_SIZE;
    }
    __privateGet(this, _reset).call(this, new Uint8Array(size), rd);
  }
  static create(r, size = DEFAULT_BUF_SIZE) {
    return r instanceof _BufReader ? r : new _BufReader(r, size);
  }
  size() {
    return __privateGet(this, _buf2).byteLength;
  }
  buffered() {
    return __privateGet(this, _w) - __privateGet(this, _r);
  }
  reset(r) {
    __privateGet(this, _reset).call(this, __privateGet(this, _buf2), r);
  }
  async read(p) {
    let rr = p.byteLength;
    if (p.byteLength === 0)
      return rr;
    if (__privateGet(this, _r) === __privateGet(this, _w)) {
      if (p.byteLength >= __privateGet(this, _buf2).byteLength) {
        const rr2 = await __privateGet(this, _rd).read(p);
        const nread = rr2 ?? 0;
        assert(nread >= 0, "negative read");
        return rr2;
      }
      __privateSet(this, _r, 0);
      __privateSet(this, _w, 0);
      rr = await __privateGet(this, _rd).read(__privateGet(this, _buf2));
      if (rr === 0 || rr === null)
        return rr;
      assert(rr >= 0, "negative read");
      __privateSet(this, _w, __privateGet(this, _w) + rr);
    }
    const copied = copy(__privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _w)), p, 0);
    __privateSet(this, _r, __privateGet(this, _r) + copied);
    return copied;
  }
  async readFull(p) {
    let bytesRead = 0;
    while (bytesRead < p.length) {
      try {
        const rr = await this.read(p.subarray(bytesRead));
        if (rr === null) {
          if (bytesRead === 0) {
            return null;
          } else {
            throw new PartialReadError();
          }
        }
        bytesRead += rr;
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = p.subarray(0, bytesRead);
        } else if (err instanceof Error) {
          const e = new PartialReadError();
          e.partial = p.subarray(0, bytesRead);
          e.stack = err.stack;
          e.message = err.message;
          e.cause = err.cause;
          throw err;
        }
        throw err;
      }
    }
    return p;
  }
  async readByte() {
    while (__privateGet(this, _r) === __privateGet(this, _w)) {
      if (__privateGet(this, _eof))
        return null;
      await __privateGet(this, _fill).call(this);
    }
    const c = __privateGet(this, _buf2)[__privateGet(this, _r)];
    __privateWrapper(this, _r)._++;
    return c;
  }
  async readString(delim) {
    if (delim.length !== 1) {
      throw new Error("Delimiter should be a single character");
    }
    const buffer = await this.readSlice(delim.charCodeAt(0));
    if (buffer === null)
      return null;
    return new TextDecoder().decode(buffer);
  }
  async readLine() {
    let line = null;
    try {
      line = await this.readSlice(LF);
    } catch (err) {
      if (err instanceof Deno.errors.BadResource) {
        throw err;
      }
      let partial;
      if (err instanceof PartialReadError) {
        partial = err.partial;
        assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
      }
      if (!(err instanceof BufferFullError)) {
        throw err;
      }
      partial = err.partial;
      if (!__privateGet(this, _eof) && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
        assert(__privateGet(this, _r) > 0, "bufio: tried to rewind past start of buffer");
        __privateWrapper(this, _r)._--;
        partial = partial.subarray(0, partial.byteLength - 1);
      }
      if (partial) {
        return { line: partial, more: !__privateGet(this, _eof) };
      }
    }
    if (line === null) {
      return null;
    }
    if (line.byteLength === 0) {
      return { line, more: false };
    }
    if (line[line.byteLength - 1] == LF) {
      let drop = 1;
      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
        drop = 2;
      }
      line = line.subarray(0, line.byteLength - drop);
    }
    return { line, more: false };
  }
  async readSlice(delim) {
    let s = 0;
    let slice;
    while (true) {
      let i = __privateGet(this, _buf2).subarray(__privateGet(this, _r) + s, __privateGet(this, _w)).indexOf(delim);
      if (i >= 0) {
        i += s;
        slice = __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _r) + i + 1);
        __privateSet(this, _r, __privateGet(this, _r) + (i + 1));
        break;
      }
      if (__privateGet(this, _eof)) {
        if (__privateGet(this, _r) === __privateGet(this, _w)) {
          return null;
        }
        slice = __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _w));
        __privateSet(this, _r, __privateGet(this, _w));
        break;
      }
      if (this.buffered() >= __privateGet(this, _buf2).byteLength) {
        __privateSet(this, _r, __privateGet(this, _w));
        const oldbuf = __privateGet(this, _buf2);
        const newbuf = __privateGet(this, _buf2).slice(0);
        __privateSet(this, _buf2, newbuf);
        throw new BufferFullError(oldbuf);
      }
      s = __privateGet(this, _w) - __privateGet(this, _r);
      try {
        await __privateGet(this, _fill).call(this);
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = slice;
        } else if (err instanceof Error) {
          const e = new PartialReadError();
          e.partial = slice;
          e.stack = err.stack;
          e.message = err.message;
          e.cause = err.cause;
          throw err;
        }
        throw err;
      }
    }
    return slice;
  }
  async peek(n) {
    if (n < 0) {
      throw Error("negative count");
    }
    let avail = __privateGet(this, _w) - __privateGet(this, _r);
    while (avail < n && avail < __privateGet(this, _buf2).byteLength && !__privateGet(this, _eof)) {
      try {
        await __privateGet(this, _fill).call(this);
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _w));
        } else if (err instanceof Error) {
          const e = new PartialReadError();
          e.partial = __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _w));
          e.stack = err.stack;
          e.message = err.message;
          e.cause = err.cause;
          throw err;
        }
        throw err;
      }
      avail = __privateGet(this, _w) - __privateGet(this, _r);
    }
    if (avail === 0 && __privateGet(this, _eof)) {
      return null;
    } else if (avail < n && __privateGet(this, _eof)) {
      return __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _r) + avail);
    } else if (avail < n) {
      throw new BufferFullError(__privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _w)));
    }
    return __privateGet(this, _buf2).subarray(__privateGet(this, _r), __privateGet(this, _r) + n);
  }
};
var BufReader = _BufReader;
_buf2 = new WeakMap();
_rd = new WeakMap();
_r = new WeakMap();
_w = new WeakMap();
_eof = new WeakMap();
_fill = new WeakMap();
_reset = new WeakMap();
var AbstractBufBase = class {
  constructor(buf) {
    this.usedBufferBytes = 0;
    this.err = null;
    this.buf = buf;
  }
  size() {
    return this.buf.byteLength;
  }
  available() {
    return this.buf.byteLength - this.usedBufferBytes;
  }
  buffered() {
    return this.usedBufferBytes;
  }
};
var _writer;
var _BufWriter = class extends AbstractBufBase {
  constructor(writer, size = DEFAULT_BUF_SIZE) {
    super(new Uint8Array(size <= 0 ? DEFAULT_BUF_SIZE : size));
    __privateAdd(this, _writer, void 0);
    __privateSet(this, _writer, writer);
  }
  static create(writer, size = DEFAULT_BUF_SIZE) {
    return writer instanceof _BufWriter ? writer : new _BufWriter(writer, size);
  }
  reset(w) {
    this.err = null;
    this.usedBufferBytes = 0;
    __privateSet(this, _writer, w);
  }
  async flush() {
    if (this.err !== null)
      throw this.err;
    if (this.usedBufferBytes === 0)
      return;
    try {
      const p = this.buf.subarray(0, this.usedBufferBytes);
      let nwritten = 0;
      while (nwritten < p.length) {
        nwritten += await __privateGet(this, _writer).write(p.subarray(nwritten));
      }
    } catch (e) {
      if (e instanceof Error) {
        this.err = e;
      }
      throw e;
    }
    this.buf = new Uint8Array(this.buf.length);
    this.usedBufferBytes = 0;
  }
  async write(data) {
    if (this.err !== null)
      throw this.err;
    if (data.length === 0)
      return 0;
    let totalBytesWritten = 0;
    let numBytesWritten = 0;
    while (data.byteLength > this.available()) {
      if (this.buffered() === 0) {
        try {
          numBytesWritten = await __privateGet(this, _writer).write(data);
        } catch (e) {
          if (e instanceof Error) {
            this.err = e;
          }
          throw e;
        }
      } else {
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        await this.flush();
      }
      totalBytesWritten += numBytesWritten;
      data = data.subarray(numBytesWritten);
    }
    numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
    this.usedBufferBytes += numBytesWritten;
    totalBytesWritten += numBytesWritten;
    return totalBytesWritten;
  }
};
var BufWriter = _BufWriter;
_writer = new WeakMap();
var _writer2;
var _BufWriterSync = class extends AbstractBufBase {
  constructor(writer, size = DEFAULT_BUF_SIZE) {
    super(new Uint8Array(size <= 0 ? DEFAULT_BUF_SIZE : size));
    __privateAdd(this, _writer2, void 0);
    __privateSet(this, _writer2, writer);
  }
  static create(writer, size = DEFAULT_BUF_SIZE) {
    return writer instanceof _BufWriterSync ? writer : new _BufWriterSync(writer, size);
  }
  reset(w) {
    this.err = null;
    this.usedBufferBytes = 0;
    __privateSet(this, _writer2, w);
  }
  flush() {
    if (this.err !== null)
      throw this.err;
    if (this.usedBufferBytes === 0)
      return;
    try {
      const p = this.buf.subarray(0, this.usedBufferBytes);
      let nwritten = 0;
      while (nwritten < p.length) {
        nwritten += __privateGet(this, _writer2).writeSync(p.subarray(nwritten));
      }
    } catch (e) {
      if (e instanceof Error) {
        this.err = e;
      }
      throw e;
    }
    this.buf = new Uint8Array(this.buf.length);
    this.usedBufferBytes = 0;
  }
  writeSync(data) {
    if (this.err !== null)
      throw this.err;
    if (data.length === 0)
      return 0;
    let totalBytesWritten = 0;
    let numBytesWritten = 0;
    while (data.byteLength > this.available()) {
      if (this.buffered() === 0) {
        try {
          numBytesWritten = __privateGet(this, _writer2).writeSync(data);
        } catch (e) {
          if (e instanceof Error) {
            this.err = e;
          }
          throw e;
        }
      } else {
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        this.flush();
      }
      totalBytesWritten += numBytesWritten;
      data = data.subarray(numBytesWritten);
    }
    numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
    this.usedBufferBytes += numBytesWritten;
    totalBytesWritten += numBytesWritten;
    return totalBytesWritten;
  }
};
var BufWriterSync = _BufWriterSync;
_writer2 = new WeakMap();

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/binary.ts
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  let code;
  let bitlen = 0;
  const max = data.length;
  const map2 = BASE64_MAP;
  for (let idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  const input = data.replace(/[\r\n=]/g, "");
  const max = input.length;
  const map2 = BASE64_MAP;
  const result = [];
  let bits = 0;
  for (let idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  const tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Buffer2(new Uint8Array(result));
}
function representYamlBinary(object) {
  const max = object.length;
  const map2 = BASE64_MAP;
  let result = "";
  let bits = 0;
  for (let idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  const tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  const buf = new Buffer2();
  try {
    if (0 > buf.readFromSync(obj))
      return true;
    return false;
  } catch {
    return false;
  } finally {
    buf.reset();
  }
}
var binary = new Type("tag:yaml.org,2002:binary", {
  construct: constructYamlBinary,
  kind: "scalar",
  predicate: isBinary,
  represent: representYamlBinary,
  resolve: resolveYamlBinary
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/bool.ts
function resolveYamlBoolean(data) {
  const max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
var bool = new Type("tag:yaml.org,2002:bool", {
  construct: constructYamlBoolean,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isBoolean,
  represent: {
    lowercase(object) {
      return object ? "true" : "false";
    },
    uppercase(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase(object) {
      return object ? "True" : "False";
    }
  },
  resolve: resolveYamlBoolean
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/float.ts
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  let value = data.replace(/_/g, "").toLowerCase();
  const sign = value[0] === "-" ? -1 : 1;
  const digits = [];
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  }
  if (value === ".nan") {
    return NaN;
  }
  if (value.indexOf(":") >= 0) {
    value.split(":").forEach((v) => {
      digits.unshift(parseFloat(v));
    });
    let valueNb = 0;
    let base = 1;
    digits.forEach((d) => {
      valueNb += d * base;
      base *= 60;
    });
    return sign * valueNb;
  }
  return sign * parseFloat(value);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (isNegativeZero(object)) {
    return "-0.0";
  }
  const res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || isNegativeZero(object));
}
var float = new Type("tag:yaml.org,2002:float", {
  construct: constructYamlFloat,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isFloat,
  represent: representYamlFloat,
  resolve: resolveYamlFloat
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/function.ts
function reconstructFunction(code) {
  const func2 = new Function(`return ${code}`)();
  if (!(func2 instanceof Function)) {
    throw new TypeError(`Expected function but got ${typeof func2}: ${code}`);
  }
  return func2;
}
var func = new Type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve(data) {
    if (data === null) {
      return false;
    }
    try {
      reconstructFunction(`${data}`);
      return true;
    } catch (_err) {
      return false;
    }
  },
  construct(data) {
    return reconstructFunction(data);
  },
  predicate(object) {
    return object instanceof Function;
  },
  represent(object) {
    return object.toString();
  }
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/int.ts
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  const max = data.length;
  let index = 0;
  let hasDigits = false;
  if (!max)
    return false;
  let ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (!isOctCode(data.charCodeAt(index)))
        return false;
      hasDigits = true;
    }
    return hasDigits && ch !== "_";
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (ch === ":")
      break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  if (ch !== ":")
    return true;
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
  let value = data;
  const digits = [];
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  let sign = 1;
  let ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(":") !== -1) {
    value.split(":").forEach((v) => {
      digits.unshift(parseInt(v, 10));
    });
    let valueInt = 0;
    let base = 1;
    digits.forEach((d) => {
      valueInt += d * base;
      base *= 60;
    });
    return sign * valueInt;
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !isNegativeZero(object);
}
var int = new Type("tag:yaml.org,2002:int", {
  construct: constructYamlInteger,
  defaultStyle: "decimal",
  kind: "scalar",
  predicate: isInteger,
  represent: {
    binary(obj) {
      return obj >= 0 ? `0b${obj.toString(2)}` : `-0b${obj.toString(2).slice(1)}`;
    },
    octal(obj) {
      return obj >= 0 ? `0${obj.toString(8)}` : `-0${obj.toString(8).slice(1)}`;
    },
    decimal(obj) {
      return obj.toString(10);
    },
    hexadecimal(obj) {
      return obj >= 0 ? `0x${obj.toString(16).toUpperCase()}` : `-0x${obj.toString(16).toUpperCase().slice(1)}`;
    }
  },
  resolve: resolveYamlInteger,
  styleAliases: {
    binary: [2, "bin"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"],
    octal: [8, "oct"]
  }
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/map.ts
var map = new Type("tag:yaml.org,2002:map", {
  construct(data) {
    return data !== null ? data : {};
  },
  kind: "mapping"
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/merge.ts
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/nil.ts
function resolveYamlNull(data) {
  const max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var nil = new Type("tag:yaml.org,2002:null", {
  construct: constructYamlNull,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isNull,
  represent: {
    canonical() {
      return "~";
    },
    lowercase() {
      return "null";
    },
    uppercase() {
      return "NULL";
    },
    camelcase() {
      return "Null";
    }
  },
  resolve: resolveYamlNull
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/omap.ts
var { hasOwn } = Object;
var _toString = Object.prototype.toString;
function resolveYamlOmap(data) {
  const objectKeys = [];
  let pairKey = "";
  let pairHasKey = false;
  for (const pair of data) {
    pairHasKey = false;
    if (_toString.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (hasOwn(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type("tag:yaml.org,2002:omap", {
  construct: constructYamlOmap,
  kind: "sequence",
  resolve: resolveYamlOmap
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/pairs.ts
var _toString2 = Object.prototype.toString;
function resolveYamlPairs(data) {
  const result = Array.from({ length: data.length });
  for (let index = 0; index < data.length; index++) {
    const pair = data[index];
    if (_toString2.call(pair) !== "[object Object]")
      return false;
    const keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  const result = Array.from({ length: data.length });
  for (let index = 0; index < data.length; index += 1) {
    const pair = data[index];
    const keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type("tag:yaml.org,2002:pairs", {
  construct: constructYamlPairs,
  kind: "sequence",
  resolve: resolveYamlPairs
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/regexp.ts
var REGEXP = /^\/(?<regexp>[\s\S]+)\/(?<modifiers>[gismuy]*)$/;
var regexp = new Type("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve(data) {
    var _a, _b;
    if (data === null || !data.length) {
      return false;
    }
    const regexp2 = `${data}`;
    if (regexp2.charAt(0) === "/") {
      if (!REGEXP.test(data)) {
        return false;
      }
      const modifiers = [...((_b = (_a = regexp2.match(REGEXP)) == null ? void 0 : _a.groups) == null ? void 0 : _b.modifiers) ?? ""];
      if (new Set(modifiers).size < modifiers.length) {
        return false;
      }
    }
    return true;
  },
  construct(data) {
    var _a;
    const { regexp: regexp2 = `${data}`, modifiers = "" } = ((_a = `${data}`.match(REGEXP)) == null ? void 0 : _a.groups) ?? {};
    return new RegExp(regexp2, modifiers);
  },
  predicate(object) {
    return object instanceof RegExp;
  },
  represent(object) {
    return object.toString();
  }
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/seq.ts
var seq = new Type("tag:yaml.org,2002:seq", {
  construct(data) {
    return data !== null ? data : [];
  },
  kind: "sequence"
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/set.ts
var { hasOwn: hasOwn2 } = Object;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  for (const key in data) {
    if (hasOwn2(data, key)) {
      if (data[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  construct: constructYamlSet,
  kind: "mapping",
  resolve: resolveYamlSet
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/str.ts
var str = new Type("tag:yaml.org,2002:str", {
  construct(data) {
    return data !== null ? data : "";
  },
  kind: "scalar"
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/timestamp.ts
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  let match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  const year = +match[1];
  const month = +match[2] - 1;
  const day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  const hour = +match[4];
  const minute = +match[5];
  const second = +match[6];
  let fraction = 0;
  if (match[7]) {
    let partFraction = match[7].slice(0, 3);
    while (partFraction.length < 3) {
      partFraction += "0";
    }
    fraction = +partFraction;
  }
  let delta = null;
  if (match[9]) {
    const tzHour = +match[10];
    const tzMinute = +(match[11] || 0);
    delta = (tzHour * 60 + tzMinute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  const date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(date) {
  return date.toISOString();
}
var timestamp = new Type("tag:yaml.org,2002:timestamp", {
  construct: constructYamlTimestamp,
  instanceOf: Date,
  kind: "scalar",
  represent: representYamlTimestamp,
  resolve: resolveYamlTimestamp
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/type/undefined.ts
var undefinedType = new Type("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve() {
    return true;
  },
  construct() {
    return void 0;
  },
  predicate(object) {
    return typeof object === "undefined";
  },
  represent() {
    return "";
  }
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema/failsafe.ts
var failsafe = new Schema({
  explicit: [str, seq, map]
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema/json.ts
var json = new Schema({
  implicit: [nil, bool, int, float],
  include: [failsafe]
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema/core.ts
var core = new Schema({
  include: [json]
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema/default.ts
var def = new Schema({
  explicit: [binary, omap, pairs, set],
  implicit: [timestamp, merge],
  include: [core]
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/schema/extended.ts
var extended = new Schema({
  explicit: [regexp, undefinedType],
  include: [def]
});

// deno:https://deno.land/std@0.147.0/encoding/_yaml/state.ts
var State = class {
  constructor(schema = def) {
    this.schema = schema;
  }
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/loader/loader_state.ts
var LoaderState = class extends State {
  constructor(input, {
    filename,
    schema,
    onWarning,
    legacy = false,
    json: json2 = false,
    listener = null
  }) {
    super(schema);
    this.input = input;
    this.documents = [];
    this.lineIndent = 0;
    this.lineStart = 0;
    this.position = 0;
    this.line = 0;
    this.result = "";
    this.filename = filename;
    this.onWarning = onWarning;
    this.legacy = legacy;
    this.json = json2;
    this.listener = listener;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
  }
};

// deno:https://deno.land/std@0.147.0/encoding/_yaml/loader/loader.ts
var { hasOwn: hasOwn3 } = Object;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isEOL(c) {
  return c === 10 || c === 13;
}
function isWhiteSpace(c) {
  return c === 9 || c === 32;
}
function isWsOrEol(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function isFlowIndicator(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  const lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = Array.from({ length: 256 });
var simpleEscapeMap = Array.from({ length: 256 });
for (let i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function generateError(state, message) {
  return new YAMLError(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML(state, _name, ...args) {
    if (state.version !== null) {
      return throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      return throwError(state, "YAML directive accepts exactly one argument");
    }
    const match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      return throwError(state, "ill-formed argument of the YAML directive");
    }
    const major = parseInt(match[1], 10);
    const minor = parseInt(match[2], 10);
    if (major !== 1) {
      return throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      return throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG(state, _name, ...args) {
    if (args.length !== 2) {
      return throwError(state, "TAG directive accepts exactly two arguments");
    }
    const handle = args[0];
    const prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      return throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (state.tagMap && hasOwn3(state.tagMap, handle)) {
      return throwError(state, `there is a previously declared suffix for "${handle}" tag handle`);
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      return throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    if (typeof state.tagMap === "undefined") {
      state.tagMap = {};
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  let result;
  if (start < end) {
    result = state.input.slice(start, end);
    if (checkJson) {
      for (let position = 0, length = result.length; position < length; position++) {
        const character = result.charCodeAt(position);
        if (!(character === 9 || 32 <= character && character <= 1114111)) {
          return throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(result)) {
      return throwError(state, "the stream contains non-printable characters");
    }
    state.result += result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  if (!isObject(source)) {
    return throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  const keys = Object.keys(source);
  for (let i = 0, len = keys.length; i < len; i++) {
    const key = keys[i];
    if (!hasOwn3(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (let index = 0, quantity = keyNode.length; index < quantity; index++) {
      if (Array.isArray(keyNode[index])) {
        return throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (result === null) {
    result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (let index = 0, quantity = valueNode.length; index < quantity; index++) {
        mergeMappings(state, result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !hasOwn3(overridableKeys, keyNode) && hasOwn3(result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      return throwError(state, "duplicated mapping key");
    }
    result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return result;
}
function readLineBreak(state) {
  const ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    return throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  let lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (isWhiteSpace(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (isEOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  let _position = state.position;
  let ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || isWsOrEol(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  const kind = state.kind;
  const result = state.result;
  let ch = state.input.charCodeAt(state.position);
  if (isWsOrEol(ch) || isFlowIndicator(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  let following;
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (isWsOrEol(following) || withinFlowCollection && isFlowIndicator(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  let captureEnd, captureStart = captureEnd = state.position;
  let hasPendingContent = false;
  let line = 0;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (isWsOrEol(following) || withinFlowCollection && isFlowIndicator(following)) {
        break;
      }
    } else if (ch === 35) {
      const preceding = state.input.charCodeAt(state.position - 1);
      if (isWsOrEol(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && isFlowIndicator(ch)) {
      break;
    } else if (isEOL(ch)) {
      line = state.line;
      const lineStart = state.lineStart;
      const lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = line;
        state.lineStart = lineStart;
        state.lineIndent = lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!isWhiteSpace(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = kind;
  state.result = result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  let ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (isEOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      return throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  return throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  let captureEnd, captureStart = captureEnd = state.position;
  let tmp;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    }
    if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (isEOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        let hexLength = tmp;
        let hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            return throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        return throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (isEOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      return throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  return throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  let ch = state.input.charCodeAt(state.position);
  let terminator;
  let isMapping = true;
  let result = {};
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    result = [];
  } else if (ch === 123) {
    terminator = 125;
  } else {
    return false;
  }
  if (state.anchor !== null && typeof state.anchor != "undefined" && typeof state.anchorMap != "undefined") {
    state.anchorMap[state.anchor] = result;
  }
  ch = state.input.charCodeAt(++state.position);
  const tag = state.tag, anchor = state.anchor;
  let readNext = true;
  let valueNode, keyNode, keyTag = keyNode = valueNode = null, isExplicitPair, isPair = isExplicitPair = false;
  let following = 0, line = 0;
  const overridableKeys = {};
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = tag;
      state.anchor = anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = result;
      return true;
    }
    if (!readNext) {
      return throwError(state, "missed comma between flow collection entries");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (isWsOrEol(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag || null;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  return throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  let chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false;
  let ch = state.input.charCodeAt(state.position);
  let folding = false;
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  let tmp = 0;
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        return throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        return throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        return throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (isWhiteSpace(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (isWhiteSpace(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!isEOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (isEOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (isWhiteSpace(ch)) {
        atMoreIndented = true;
        state.result += repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += repeat("\n", emptyLines);
      }
    } else {
      state.result += repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    const captureStart = state.position;
    while (!isEOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  let line, following, detected = false, ch;
  const tag = state.tag, anchor = state.anchor, result = [];
  if (state.anchor !== null && typeof state.anchor !== "undefined" && typeof state.anchorMap !== "undefined") {
    state.anchorMap[state.anchor] = result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!isWsOrEol(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === line || state.lineIndent > nodeIndent) && ch !== 0) {
      return throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = tag;
    state.anchor = anchor;
    state.kind = "sequence";
    state.result = result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  const tag = state.tag, anchor = state.anchor, result = {}, overridableKeys = {};
  let following, allowCompact = false, line, pos, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.anchor !== null && typeof state.anchor !== "undefined" && typeof state.anchorMap !== "undefined") {
    state.anchorMap[state.anchor] = result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    line = state.line;
    pos = state.position;
    if ((ch === 63 || ch === 58) && isWsOrEol(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        return throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === line) {
        ch = state.input.charCodeAt(state.position);
        while (isWhiteSpace(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!isWsOrEol(ch)) {
            return throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          return throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = tag;
          state.anchor = anchor;
          return true;
        }
      } else if (detected) {
        return throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = tag;
        state.anchor = anchor;
        return true;
      }
    } else {
      break;
    }
    if (state.line === line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, result, overridableKeys, keyTag, keyNode, valueNode, line, pos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0) {
      return throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, result, overridableKeys, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = tag;
    state.anchor = anchor;
    state.kind = "mapping";
    state.result = result;
  }
  return detected;
}
function readTagProperty(state) {
  let position, isVerbatim = false, isNamed = false, tagHandle = "", tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    return throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      return throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !isWsOrEol(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            return throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          position = state.position + 1;
        } else {
          return throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      return throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    return throwError(state, `tag name cannot contain such characters: ${tagName}`);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (typeof state.tagMap !== "undefined" && hasOwn3(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = `!${tagName}`;
  } else if (tagHandle === "!!") {
    state.tag = `tag:yaml.org,2002:${tagName}`;
  } else {
    return throwError(state, `undeclared tag handle "${tagHandle}"`);
  }
  return true;
}
function readAnchorProperty(state) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    return throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  const position = state.position;
  while (ch !== 0 && !isWsOrEol(ch) && !isFlowIndicator(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === position) {
    return throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(position, state.position);
  return true;
}
function readAlias(state) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  const _position = state.position;
  while (ch !== 0 && !isWsOrEol(ch) && !isFlowIndicator(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    return throwError(state, "name of an alias node must contain at least one character");
  }
  const alias = state.input.slice(_position, state.position);
  if (typeof state.anchorMap !== "undefined" && !hasOwn3(state.anchorMap, alias)) {
    return throwError(state, `unidentified alias "${alias}"`);
  }
  if (typeof state.anchorMap !== "undefined") {
    state.result = state.anchorMap[alias];
  }
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  let allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, type, flowIndent, blockIndent;
  if (state.listener && state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  const allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    const cond = CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext;
    flowIndent = cond ? parentIndent : parentIndent + 1;
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            return throwError(state, "alias node should not have Any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      for (let typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex++) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) {
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (hasOwn3(state.typeMap[state.kind || "fallback"], state.tag)) {
      type = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type.kind !== state.kind) {
        return throwError(state, `unacceptable node kind for !<${state.tag}> tag; it should be "${type.kind}", not "${state.kind}"`);
      }
      if (!type.resolve(state.result)) {
        return throwError(state, `cannot resolve a node with !<${state.tag}> explicit tag`);
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      return throwError(state, `unknown tag !<${state.tag}>`);
    }
  }
  if (state.listener && state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  const documentStart = state.position;
  let position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    position = state.position;
    while (ch !== 0 && !isWsOrEol(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      return throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (isWhiteSpace(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !isEOL(ch));
        break;
      }
      if (isEOL(ch))
        break;
      position = state.position;
      while (ch !== 0 && !isWsOrEol(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (hasOwn3(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, ...directiveArgs);
    } else {
      throwWarning(state, `unknown document directive "${directiveName}"`);
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    return throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    return throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  const state = new LoaderState(input, options);
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function load(input, options) {
  const documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return;
  }
  if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLError("expected a single document in the stream, but found more");
}

// deno:https://deno.land/std@0.147.0/encoding/_yaml/parse.ts
function parse(content, options) {
  return load(content, options);
}

// deno:https://deno.land/std@0.147.0/encoding/_yaml/dumper/dumper_state.ts
var { hasOwn: hasOwn4 } = Object;

// deno:https://deno.land/std@0.147.0/encoding/_yaml/dumper/dumper.ts
var { hasOwn: hasOwn5 } = Object;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/async/event-emitter.ts
function createEventEmitter() {
  const listeners = {};
  const eventEmitter = {
    emit(type, event) {
      var _a, _b;
      (_a = listeners[type]) == null ? void 0 : _a.forEach((listener) => listener(event, type));
      type !== "*" && ((_b = listeners["*"]) == null ? void 0 : _b.forEach((listener) => listener(event, type)));
    },
    on(type, listener) {
      (listeners[type] || (listeners[type] = /* @__PURE__ */ new Set())).add(listener);
      return () => {
        var _a;
        return (_a = listeners[type]) == null ? void 0 : _a.delete(listener);
      };
    },
    off(type) {
      delete listeners[type];
    }
  };
  return eventEmitter;
}

// deno:file:///home/runner/work/pbkit/pbkit/core/parser/recursive-descent-parser.ts
var eof = Symbol("<EOF>");
function createRecursiveDescentParser(input, config) {
  const debug = !!(config == null ? void 0 : config.debug);
  let cnt = 0;
  const lines = input.split("\n");
  const parser = __spreadProps(__spreadValues({}, createEventEmitter()), {
    input,
    loc: 0,
    offsetToColRow: (offset) => offsetToColRow(lines, offset),
    colRowToOffset: (colRow) => colRowToOffset(lines, colRow),
    getAroundText: (loc, length, window) => getAroundText(lines, loc, length, window),
    try(pattern) {
      const loc = parser.loc;
      try {
        return parser.accept(pattern);
      } finally {
        parser.loc = loc;
      }
    },
    accept(pattern) {
      cnt++;
      if (cnt > input.length * 5)
        throw `infinite loop`;
      if (pattern === eof)
        return acceptEof();
      if (typeof pattern === "string")
        return acceptString(pattern);
      return acceptRegex(pattern);
    },
    expect(acceptPattern, expectedPatterns, mistakePatterns) {
      const result = parser.accept(acceptPattern);
      const _expectedPatterns = expectedPatterns ? [acceptPattern, ...expectedPatterns] : [acceptPattern];
      if (result == null) {
        throw new SyntaxError(parser, _expectedPatterns, mistakePatterns);
      } else {
        return result;
      }
    }
  });
  function acceptEof() {
    if (parser.loc < input.length)
      return;
    return { start: parser.loc, end: parser.loc, text: "" };
  }
  function acceptString(pattern) {
    const start = parser.loc;
    const end = start + pattern.length;
    const text = input.slice(start, end);
    if (text !== pattern)
      return;
    parser.loc = end;
    debug && console.log(text);
    return { start, end, text };
  }
  function acceptRegex(pattern) {
    pattern.lastIndex = 0;
    const execArray = pattern.exec(input.substr(parser.loc));
    if (execArray == null)
      return;
    const text = execArray[0];
    const start = parser.loc + execArray.index;
    const end = start + text.length;
    parser.loc = end;
    debug && console.log(text);
    return { start, end, text };
  }
  return parser;
}
var SyntaxError = class extends Error {
  constructor(parser, expectedPatterns, mistakePatterns = []) {
    super();
    this.parser = parser;
    this.expectedPatterns = expectedPatterns;
    this.mistakePatterns = mistakePatterns;
    const colRow = this.colRow;
    const got = this.got;
    const length = got === eof ? 1 : got.length;
    const expectedPatternsText = expectedPatterns.map(patternToString).join(" or ");
    this.message = `at line ${colRow.row + 1}, column ${colRow.col + 1}:

expected ${expectedPatternsText}, got ${patternToString(got)}

` + parser.getAroundText(parser.loc, length);
  }
  get got() {
    const parser = this.parser;
    for (const mistakePattern of this.mistakePatterns) {
      const token = parser.try(mistakePattern);
      if (token)
        return token.text;
    }
    return parser.input.charAt(parser.loc) || eof;
  }
  get colRow() {
    return this.parser.offsetToColRow(this.parser.loc);
  }
};
function patternToString(pattern) {
  if (pattern === eof)
    return "<EOF>";
  if (typeof pattern === "string")
    return JSON.stringify(pattern);
  return pattern.toString();
}
function offsetToColRow(lines, offset) {
  let row = 0;
  let col = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (offset < line.length + 1) {
      row = i;
      col = offset;
      break;
    }
    offset -= line.length + 1;
  }
  return { col, row };
}
function colRowToOffset(lines, { col, row }) {
  let offset = 0;
  for (let i = 0; i < row; i++) {
    offset += lines[i].length + 1;
  }
  return offset + col;
}
function getAroundText(lines, loc, length = 1, window = 5) {
  const colRow = offsetToColRow(lines, loc);
  const headCount = Math.min(1, (window >> 1) + window % 2);
  const tailCount = window >> 1;
  const headStart = Math.max(0, colRow.row - headCount - 1);
  const headEnd = colRow.row + 1;
  const tailStart = colRow.row + 1;
  const tailEnd = colRow.row + tailCount + 1;
  const heads = lines.slice(headStart, headEnd);
  const tails = lines.slice(tailStart, tailEnd);
  const lineNumberDigitCount = tailEnd.toString().length;
  const headTexts = heads.map((line, index) => {
    const lineNumber = index + headStart + 1;
    const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);
    return lineNumberText + " | " + line;
  }).join("\n");
  const tailTexts = tails.map((line, index) => {
    const lineNumber = index + tailStart + 1;
    const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);
    return lineNumberText + " | " + line;
  }).join("\n");
  return [
    headTexts,
    new Array(lineNumberDigitCount + 1 + 1).join(" ") + " | " + new Array(colRow.col + 1).join(" ") + new Array(length + 1).join("^"),
    tailTexts
  ].join("\n");
}

// deno:file:///home/runner/work/pbkit/pbkit/core/parser/proto.ts
var createProtoParser = createRecursiveDescentParser;
function parse2(text) {
  const comments = [];
  const parser = createProtoParser(text);
  parser.on("comment", (comment) => comments.push(comment));
  const statements = acceptStatements(parser, [
    acceptSyntax,
    acceptImport,
    acceptPackage,
    acceptOption,
    acceptMessage,
    acceptEnum,
    acceptExtend,
    acceptService,
    acceptEmpty
  ]);
  const ast = { statements };
  return { ast, parser, comments };
}
function mergeSpans(spans) {
  let start = Infinity;
  let end = -Infinity;
  for (let i = 0; i < spans.length; ++i) {
    if (spans[i] == null)
      continue;
    const span = Array.isArray(spans[i]) ? mergeSpans(spans[i]) : spans[i];
    start = Math.min(start, span.start);
    end = Math.max(end, span.end);
  }
  return { start, end };
}
function acceptPatternAndThen(pattern, then) {
  return function accept(parser) {
    const token = parser.accept(pattern);
    if (!token)
      return;
    return then(token);
  };
}
function choice(acceptFns) {
  return function accept(parser) {
    for (const acceptFn of acceptFns) {
      const node = acceptFn(parser);
      if (node)
        return node;
    }
  };
}
function many(parser, acceptFn) {
  const nodes = [];
  let node;
  while (node = acceptFn(parser))
    nodes.push(node);
  return nodes;
}
function acceptComplexSequence(parser, expectFnSeq, escapePattern) {
  const result = {};
  let partial = false;
  let hasNewline = false;
  let recoveryPoint;
  for (const [key, expectFn] of expectFnSeq) {
    const loc = parser.loc;
    hasNewline = skipWsAndComments2(parser);
    if (hasNewline && !recoveryPoint) {
      recoveryPoint = { loc: parser.loc, result: __spreadValues({}, result) };
    }
    try {
      result[key] = expectFn(parser);
    } catch {
      parser.loc = loc;
      partial = true;
      if (escapePattern && parser.try(escapePattern))
        break;
    }
  }
  if (partial && recoveryPoint) {
    parser.loc = recoveryPoint.loc;
    return { partial, result: recoveryPoint.result };
  }
  return { partial, result };
}
function acceptStatements(parser, acceptStatementFns) {
  const statements = [];
  statements:
    while (true) {
      const { commentGroups, trailingNewline } = skipWsAndSweepComments(parser);
      let leadingComments;
      let leadingDetachedComments;
      if (trailingNewline) {
        leadingComments = [];
        leadingDetachedComments = commentGroups;
      } else {
        if (commentGroups.length < 1) {
          leadingComments = [];
          leadingDetachedComments = [];
        } else {
          leadingComments = [commentGroups.pop()];
          leadingDetachedComments = commentGroups;
        }
      }
      for (const acceptStatementFn of acceptStatementFns) {
        const statement = acceptStatementFn(parser, leadingComments, leadingDetachedComments);
        if (statement) {
          statements.push(statement);
          continue statements;
        }
      }
      break;
    }
  return statements;
}
var whitespacePattern = /^\s+/;
var whitespaceWithoutNewlinePattern = /^[ \f\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
var newlinePattern = /^\r?\n/;
var multilineCommentPattern = /^\/\*(?:.|\r?\n)*?\*\//;
var singlelineCommentPattern = /^\/\/.*(?:\r?\n|$)/;
var intLitPattern = /^0(?:x[0-9a-f]+|[0-7]*)|^[1-9]\d*/i;
var floatLitPattern = /^\d+\.\d*(?:e[-+]?\d+)?|^\d+e[-+]?\d+|^\.\d+(?:e[-+]?\d+)?|^inf|^nan/i;
var boolLitPattern = /^true|^false/;
var strLitPattern = /^'(?:\\x[0-9a-f]{2}|\\[0-7]{3}|\\[0-7]|\\[abfnrtv\\\?'"]|[^'\0\n\\])*'|^"(?:\\x[0-9a-f]{2}|\\[0-7]{3}|\\[0-7]|\\[abfnrtv\\\?'"]|[^"\0\n\\])*"/i;
var identPattern = /^[a-z_][a-z0-9_]*/i;
var messageBodyStatementKeywordPattern = /^(?:enum|message|extend|extensions|group|option|oneof|map|reserved)\b/;
var acceptDot = acceptPatternAndThen(".", (dot) => __spreadValues({ type: "dot" }, dot));
var acceptComma = acceptPatternAndThen(",", (comma) => __spreadValues({ type: "comma" }, comma));
var acceptSemi = acceptPatternAndThen(";", (semi) => __spreadValues({ type: "semi" }, semi));
function expectSemi(parser) {
  const semi = acceptSemi(parser);
  if (semi)
    return semi;
  throw new SyntaxError(parser, [";"]);
}
var acceptIdent = acceptPatternAndThen(identPattern, (ident) => __spreadValues({ type: "ident" }, ident));
function acceptSpecialToken(parser, type, pattern = identPattern) {
  const token = parser.accept(pattern);
  if (!token)
    return;
  return __spreadValues({ type }, token);
}
function acceptKeyword(parser, pattern = identPattern) {
  return acceptSpecialToken(parser, "keyword", pattern);
}
function acceptCommentGroup(parser) {
  const loc = parser.loc;
  const comments = [];
  while (true) {
    const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
    if (whitespace)
      continue;
    const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
    if (multilineComment) {
      parser.emit("comment", multilineComment);
      comments.push(multilineComment);
      continue;
    }
    const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
    if (singlelineComment) {
      parser.emit("comment", singlelineComment);
      comments.push(singlelineComment);
      continue;
    }
    break;
  }
  if (comments.length < 1) {
    parser.loc = loc;
    return;
  }
  return __spreadProps(__spreadValues({}, mergeSpans(comments)), {
    type: "comment-group",
    comments
  });
}
function acceptTrailingComments(parser) {
  const loc = parser.loc;
  const comments = [];
  while (true) {
    const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
    if (whitespace)
      continue;
    const newline = parser.accept(newlinePattern);
    if (newline)
      break;
    const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
    if (multilineComment) {
      comments.push(multilineComment);
      continue;
    }
    const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
    if (singlelineComment) {
      comments.push(singlelineComment);
      break;
    }
    break;
  }
  if (comments.length < 1) {
    parser.loc = loc;
    return [];
  }
  return [__spreadProps(__spreadValues({}, mergeSpans(comments)), {
    type: "comment-group",
    comments
  })];
}
function skipWsAndSweepComments(parser) {
  const commentGroups = [];
  let trailingNewline = false;
  parser.accept(whitespacePattern);
  while (true) {
    const commentGroup = acceptCommentGroup(parser);
    if (commentGroup) {
      commentGroups.push(commentGroup);
      trailingNewline = false;
      continue;
    }
    const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
    if (whitespace)
      continue;
    const newline = parser.accept(newlinePattern);
    if (newline) {
      trailingNewline = true;
      continue;
    }
    break;
  }
  return {
    commentGroups,
    trailingNewline
  };
}
function skipWsAndComments(parser) {
  while (true) {
    const whitespace = parser.accept(whitespacePattern);
    if (whitespace)
      continue;
    const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
    if (multilineComment) {
      parser.emit("comment", multilineComment);
      continue;
    }
    const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
    if (singlelineComment) {
      parser.emit("comment", singlelineComment);
      continue;
    }
    break;
  }
  return;
}
function skipWsAndComments2(parser) {
  let hasNewline = false;
  while (true) {
    const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
    if (whitespace)
      continue;
    const newline = parser.accept(newlinePattern);
    if (newline) {
      hasNewline = true;
      continue;
    }
    const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
    if (multilineComment) {
      parser.emit("comment", multilineComment);
      continue;
    }
    const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
    if (singlelineComment) {
      parser.emit("comment", singlelineComment);
      hasNewline = true;
      continue;
    }
    break;
  }
  return hasNewline;
}
function acceptFullIdent(parser) {
  const identOrDots = many(parser, choice([
    acceptDot,
    acceptIdent
  ]));
  if (identOrDots.length < 1)
    return;
  return __spreadProps(__spreadValues({}, mergeSpans(identOrDots)), {
    type: "full-ident",
    identOrDots
  });
}
function expectFullIdent(parser) {
  const fullIdent = acceptFullIdent(parser);
  if (fullIdent)
    return fullIdent;
  throw new SyntaxError(parser, [".", identPattern]);
}
function acceptType(parser) {
  const identOrDots = many(parser, choice([
    acceptDot,
    acceptIdent
  ]));
  if (identOrDots.length < 1)
    return;
  return __spreadProps(__spreadValues({}, mergeSpans(identOrDots)), {
    type: "type",
    identOrDots
  });
}
function expectType(parser) {
  const type = acceptType(parser);
  if (type)
    return type;
  throw new SyntaxError(parser, [".", identPattern]);
}
function acceptIntLit(parser) {
  const intLit = parser.accept(intLitPattern);
  if (!intLit)
    return;
  return __spreadValues({ type: "int-lit" }, intLit);
}
function expectIntLit(parser) {
  const intLit = acceptIntLit(parser);
  if (intLit)
    return intLit;
  throw new SyntaxError(parser, [intLitPattern]);
}
function acceptSignedIntLit(parser) {
  const loc = parser.loc;
  const sign = parser.accept("-") ?? parser.accept("+");
  const intLit = acceptIntLit(parser);
  if (!intLit) {
    parser.loc = loc;
    return;
  }
  return __spreadProps(__spreadValues({}, mergeSpans([sign, intLit])), {
    type: "signed-int-lit",
    sign,
    value: intLit
  });
}
function expectSignedIntLit(parser) {
  const signedIntLit = acceptSignedIntLit(parser);
  if (signedIntLit)
    return signedIntLit;
  throw new SyntaxError(parser, ["-", intLitPattern]);
}
function acceptFloatLit(parser) {
  const floatLit = parser.accept(floatLitPattern);
  if (!floatLit)
    return;
  return __spreadValues({ type: "float-lit" }, floatLit);
}
function acceptSignedFloatLit(parser) {
  const loc = parser.loc;
  const sign = parser.accept("-") ?? parser.accept("+");
  const floatLit = acceptFloatLit(parser);
  if (!floatLit) {
    parser.loc = loc;
    return;
  }
  return __spreadProps(__spreadValues({}, mergeSpans([sign, floatLit])), {
    type: "signed-float-lit",
    sign,
    value: floatLit
  });
}
function acceptBoolLit(parser) {
  const boolLit = parser.accept(boolLitPattern);
  if (!boolLit)
    return;
  return __spreadValues({ type: "bool-lit" }, boolLit);
}
function acceptStrLit(parser) {
  const strLit = parser.accept(strLitPattern);
  if (!strLit)
    return;
  const tokens = [strLit];
  while (true) {
    skipWsAndComments(parser);
    const strLit2 = parser.accept(strLitPattern);
    if (!strLit2)
      break;
    tokens.push(strLit2);
  }
  return __spreadProps(__spreadValues({}, mergeSpans(tokens)), { type: "str-lit", tokens });
}
function expectStrLit(parser) {
  const strLit = acceptStrLit(parser);
  if (strLit)
    return strLit;
  throw new SyntaxError(parser, [strLitPattern]);
}
function acceptAggregate(parser) {
  const parenthesisOpen = parser.accept("{");
  if (!parenthesisOpen)
    return;
  let character = parenthesisOpen;
  let depth = 1;
  while (character = parser.expect(/^(?:\s|\S)/)) {
    switch (character.text) {
      case "{":
        ++depth;
        break;
      case "}":
        --depth;
        break;
    }
    if (depth === 0) {
      break;
    }
  }
  return __spreadProps(__spreadValues({}, mergeSpans([parenthesisOpen, character])), {
    type: "aggregate"
  });
}
function acceptConstant(parser) {
  return acceptSignedFloatLit(parser) ?? acceptSignedIntLit(parser) ?? acceptStrLit(parser) ?? acceptBoolLit(parser) ?? acceptFullIdent(parser) ?? acceptAggregate(parser);
}
function expectConstant(parser) {
  const constant = acceptConstant(parser);
  if (constant)
    return constant;
  throw new SyntaxError(parser, [
    identPattern,
    "-",
    "+",
    intLitPattern,
    strLitPattern,
    boolLitPattern
  ]);
}
function acceptOptionNameSegment(parser) {
  const bracketOpen = parser.accept("(");
  const name = acceptFullIdent(parser);
  if (!name) {
    if (bracketOpen)
      throw new SyntaxError(parser, [identPattern]);
    return;
  }
  const bracketClose = parser[bracketOpen ? "expect" : "accept"](")");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, name, bracketClose])), {
    type: "option-name-segment",
    bracketOpen,
    name,
    bracketClose
  });
}
function acceptOptionName(parser) {
  const optionNameSegmentOrDots = many(parser, choice([
    acceptDot,
    acceptOptionNameSegment
  ]));
  if (optionNameSegmentOrDots.length < 1)
    return;
  return __spreadProps(__spreadValues({}, mergeSpans(optionNameSegmentOrDots)), {
    type: "option-name",
    optionNameSegmentOrDots
  });
}
function expectOptionName(parser) {
  const optionName = acceptOptionName(parser);
  if (optionName)
    return optionName;
  throw new SyntaxError(parser, ["(", identPattern]);
}
function acceptSyntax(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "syntax");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const quoteOpen = parser.expect(/^['"]/);
  const syntax = parser.expect(/^[^'"]+/);
  const quoteClose = parser.expect(/^['"]/);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "syntax",
    keyword,
    eq,
    quoteOpen,
    syntax,
    quoteClose,
    semi
  });
}
function acceptImport(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "import");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const weakOrPublic = parser.accept(/^weak|^public/);
  skipWsAndComments(parser);
  const strLit = expectStrLit(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "import",
    keyword,
    weakOrPublic,
    strLit,
    semi
  });
}
function acceptPackage(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "package");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const fullIdent = expectFullIdent(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "package",
    keyword,
    fullIdent,
    semi
  });
}
function acceptOption(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, /^option\b/);
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const optionName = expectOptionName(parser);
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const constant = expectConstant(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "option",
    keyword,
    optionName,
    eq,
    constant,
    semi
  });
}
function acceptEmpty(parser, leadingComments, leadingDetachedComments) {
  const semi = acceptSemi(parser);
  if (!semi)
    return;
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "empty",
    semi
  });
}
function acceptFieldOption(parser) {
  const optionName = acceptOptionName(parser);
  if (!optionName)
    return;
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const constant = expectConstant(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([optionName, constant])), {
    type: "field-option",
    optionName,
    eq,
    constant
  });
}
function acceptFieldOptions(parser) {
  const bracketOpen = parser.accept("[");
  if (!bracketOpen)
    return;
  const fieldOptionOrCommas = many(parser, choice([
    skipWsAndComments,
    acceptComma,
    acceptFieldOption
  ]));
  const bracketClose = parser.expect("]");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "field-options",
    bracketOpen,
    fieldOptionOrCommas,
    bracketClose
  });
}
function acceptEnumField(parser, leadingComments, leadingDetachedComments) {
  const fieldName = parser.accept(identPattern);
  if (!fieldName)
    return;
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const fieldNumber = expectSignedIntLit(parser);
  skipWsAndComments(parser);
  const fieldOptions = acceptFieldOptions(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    fieldName,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "enum-field",
    fieldName,
    eq,
    fieldNumber,
    fieldOptions,
    semi
  });
}
function expectEnumBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptOption,
    acceptReserved,
    acceptEnumField,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "enum-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function acceptEnum(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "enum");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const enumName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const enumBody = expectEnumBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    enumBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "enum",
    keyword,
    enumName,
    enumBody
  });
}
function acceptField(parser, leadingComments, leadingDetachedComments) {
  const loc = parser.loc;
  const fieldLabel = acceptKeyword(parser, /^required|^optional|^repeated/);
  skipWsAndComments(parser);
  const fieldType = acceptType(parser);
  if (!fieldType) {
    parser.loc = loc;
    return;
  }
  const rest = acceptComplexSequence(parser, [
    ["fieldName", (parser2) => parser2.expect(identPattern)],
    ["eq", (parser2) => parser2.expect("=")],
    ["fieldNumber", expectIntLit],
    ["fieldOptions", acceptFieldOptions],
    ["semi", expectSemi]
  ], messageBodyStatementKeywordPattern);
  const trailingComments = rest.result.semi ? acceptTrailingComments(parser) : [];
  const type = rest.partial ? "malformed-field" : "field";
  return __spreadValues(__spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    fieldLabel,
    fieldType,
    Object.values(rest.result),
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type,
    fieldLabel,
    fieldType
  }), rest.result);
}
function acceptOneofField(parser, leadingComments, leadingDetachedComments) {
  const fieldType = acceptType(parser);
  if (!fieldType)
    return;
  skipWsAndComments(parser);
  const fieldName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const fieldNumber = expectIntLit(parser);
  skipWsAndComments(parser);
  const fieldOptions = acceptFieldOptions(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    fieldType,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "oneof-field",
    fieldType,
    fieldName,
    eq,
    fieldNumber,
    fieldOptions,
    semi
  });
}
function acceptMapField(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "map");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const typeBracketOpen = parser.expect("<");
  skipWsAndComments(parser);
  const keyType = expectType(parser);
  skipWsAndComments(parser);
  const typeSep = parser.expect(",");
  skipWsAndComments(parser);
  const valueType = expectType(parser);
  skipWsAndComments(parser);
  const typeBracketClose = parser.expect(">");
  skipWsAndComments(parser);
  const mapName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const fieldNumber = expectIntLit(parser);
  skipWsAndComments(parser);
  const fieldOptions = acceptFieldOptions(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "map-field",
    keyword,
    typeBracketOpen,
    keyType,
    typeSep,
    valueType,
    typeBracketClose,
    mapName,
    eq,
    fieldNumber,
    fieldOptions,
    semi
  });
}
function expectOneofBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptOneofGroup,
    acceptOption,
    acceptOneofField,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "oneof-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function acceptOneof(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "oneof");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const oneofName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const oneofBody = expectOneofBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    oneofBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "oneof",
    keyword,
    oneofName,
    oneofBody
  });
}
var acceptMax = acceptPatternAndThen("max", (max) => __spreadValues({ type: "max" }, max));
function acceptRange(parser) {
  const rangeStart = acceptIntLit(parser);
  if (!rangeStart)
    return;
  skipWsAndComments(parser);
  const to = acceptKeyword(parser, "to");
  if (!to) {
    return {
      start: rangeStart.start,
      end: rangeStart.end,
      type: "range",
      rangeStart
    };
  }
  skipWsAndComments(parser);
  const rangeEnd = acceptIntLit(parser) ?? acceptMax(parser);
  if (!rangeEnd)
    throw new SyntaxError(parser, [intLitPattern, "max"]);
  return __spreadProps(__spreadValues({}, mergeSpans([rangeStart, rangeEnd])), {
    type: "range",
    rangeStart,
    to,
    rangeEnd
  });
}
function expectRanges(parser) {
  const rangeOrCommas = many(parser, choice([
    skipWsAndComments,
    acceptComma,
    acceptRange
  ]));
  return __spreadProps(__spreadValues({}, mergeSpans(rangeOrCommas)), {
    type: "ranges",
    rangeOrCommas
  });
}
function acceptExtensions(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "extensions");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const ranges = expectRanges(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "extensions",
    keyword,
    ranges,
    semi
  });
}
function expectFieldNames(parser) {
  const strLitOrCommas = many(parser, choice([
    skipWsAndComments,
    acceptComma,
    acceptStrLit
  ]));
  return __spreadProps(__spreadValues({}, mergeSpans(strLitOrCommas)), {
    type: "field-names",
    strLitOrCommas
  });
}
function acceptReserved(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "reserved");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const reserved = parser.try(intLitPattern) ? expectRanges(parser) : expectFieldNames(parser);
  skipWsAndComments(parser);
  const semi = expectSemi(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semi,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "reserved",
    keyword,
    reserved,
    semi
  });
}
function expectExtendBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptGroup,
    acceptField,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "extend-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function acceptExtend(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "extend");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const messageType = expectType(parser);
  skipWsAndComments(parser);
  const extendBody = expectExtendBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    extendBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "extend",
    keyword,
    messageType,
    extendBody
  });
}
function acceptGroup(parser, leadingComments, leadingDetachedComments) {
  const loc = parser.loc;
  const groupLabel = acceptKeyword(parser, /^required|^optional|^repeated/);
  if (!groupLabel) {
    parser.loc = loc;
    return;
  }
  skipWsAndComments(parser);
  const keyword = acceptKeyword(parser, "group");
  if (!keyword) {
    parser.loc = loc;
    return;
  }
  skipWsAndComments(parser);
  const groupName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const fieldNumber = expectIntLit(parser);
  skipWsAndComments(parser);
  const fieldOptions = acceptFieldOptions(parser);
  skipWsAndComments(parser);
  const messageBody = expectMessageBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    groupLabel,
    messageBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "group",
    groupLabel,
    keyword,
    groupName,
    eq,
    fieldNumber,
    fieldOptions,
    messageBody
  });
}
function acceptOneofGroup(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "group");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const groupName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const eq = parser.expect("=");
  skipWsAndComments(parser);
  const fieldNumber = expectIntLit(parser);
  skipWsAndComments(parser);
  const messageBody = expectMessageBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    messageBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "oneof-group",
    keyword,
    groupName,
    eq,
    fieldNumber,
    messageBody
  });
}
function expectMessageBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptGroup,
    acceptEnum,
    acceptMessage,
    acceptExtend,
    acceptExtensions,
    acceptOption,
    acceptOneof,
    acceptMapField,
    acceptReserved,
    acceptField,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "message-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function acceptMessage(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "message");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const messageName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const messageBody = expectMessageBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    messageBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "message",
    keyword,
    messageName,
    messageBody
  });
}
function expectRpcType(parser) {
  const bracketOpen = parser.expect("(");
  skipWsAndComments(parser);
  const stream = acceptKeyword(parser, "stream");
  skipWsAndComments(parser);
  const messageType = expectType(parser);
  skipWsAndComments(parser);
  const bracketClose = parser.expect(")");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    bracketOpen,
    stream,
    messageType,
    bracketClose
  });
}
function acceptRpc(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "rpc");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const rpcName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const reqType = expectRpcType(parser);
  skipWsAndComments(parser);
  const returns = parser.expect("returns");
  skipWsAndComments(parser);
  const resType = expectRpcType(parser);
  skipWsAndComments(parser);
  const semiOrRpcBody = acceptSemi(parser) ?? expectRpcBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    semiOrRpcBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "rpc",
    keyword,
    rpcName,
    reqType,
    returns,
    resType,
    semiOrRpcBody
  });
}
function expectRpcBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptOption,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "rpc-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function expectServiceBody(parser) {
  const bracketOpen = parser.expect("{");
  const statements = acceptStatements(parser, [
    acceptOption,
    acceptRpc,
    acceptEmpty
  ]);
  const bracketClose = parser.expect("}");
  return __spreadProps(__spreadValues({}, mergeSpans([bracketOpen, bracketClose])), {
    type: "service-body",
    bracketOpen,
    statements,
    bracketClose
  });
}
function acceptService(parser, leadingComments, leadingDetachedComments) {
  const keyword = acceptKeyword(parser, "service");
  if (!keyword)
    return;
  skipWsAndComments(parser);
  const serviceName = parser.expect(identPattern);
  skipWsAndComments(parser);
  const serviceBody = expectServiceBody(parser);
  const trailingComments = acceptTrailingComments(parser);
  return __spreadProps(__spreadValues({}, mergeSpans([
    leadingDetachedComments,
    leadingComments,
    keyword,
    serviceBody,
    trailingComments
  ])), {
    leadingComments,
    trailingComments,
    leadingDetachedComments,
    type: "service",
    keyword,
    serviceName,
    serviceBody
  });
}

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/array.ts
function toPojoSet(arr) {
  const result = {};
  for (const item of arr)
    result[item] = item;
  return result;
}

// deno:file:///home/runner/work/pbkit/pbkit/core/schema/ast-util.ts
function findNodeByType(nodes, type) {
  return nodes.find((node) => node.type === type);
}
function filterNodesByType(nodes, type) {
  return nodes.filter((node) => node.type === type);
}
function filterNodesByTypes(nodes, types) {
  return nodes.filter((node) => types.includes(node.type));
}

// deno:file:///home/runner/work/pbkit/pbkit/core/schema/comment.ts
function unwrap(text) {
  if (isSinglelineComment(text))
    return unwrapSinglelineComment(text);
  if (isDocComment(text))
    return unwrapDocComment(text);
  if (isMultilineComment(text))
    return unwrapMultilineComment(text);
  return text;
}
function unwrapSinglelineComment(text) {
  return text.replace(/^\/\/+\s?/, "").replace(/\r?\n$/, "");
}
function unwrapMultilineComment(text) {
  if (!text.startsWith("/*") || !text.endsWith("*/"))
    return text;
  const body = text.slice(2, -2).replace(/^[ \t\r]*\n|\n[ \t\r]*$/g, "");
  const lines = body.split("\n");
  return removeCommonLeadingSpaces(lines).join("\n");
}
function unwrapDocComment(text) {
  const match = /\/\*\*[\s\S]*?\n([\s\S]+?)\n\s*\*\//.exec(text);
  if (!match)
    return text;
  const [, body] = match;
  const lines = body.split("\n").map((line) => line.replace(/\s*\*/, ""));
  return removeCommonLeadingSpaces(lines).join("\n");
}
function isSinglelineComment(text) {
  return text.startsWith("//");
}
function isMultilineComment(text) {
  return text.startsWith("/*");
}
function isDocComment(text) {
  return text.startsWith("/**");
}
function removeCommonLeadingSpaces(lines) {
  const commonLeadingSpaceCount = Math.min(...lines.map(getLeadingSpaceCount));
  return lines.map((line) => line.slice(commonLeadingSpaceCount));
}
function getLeadingSpaceCount(line) {
  let count = 0;
  for (const char of line) {
    if (char === " ")
      ++count;
    else
      break;
  }
  return count;
}

// deno:file:///home/runner/work/pbkit/pbkit/core/visitor/index.ts
var visitor = {
  visitProto(visitor2, node) {
    for (const statement of node.statements) {
      visitor2.visitTopLevelStatement(visitor2, statement);
    }
  },
  visitTopLevelStatement(visitor2, node) {
    switch (node.type) {
      case "syntax":
        return visitor2.visitSyntax(visitor2, node);
      case "import":
        return visitor2.visitImport(visitor2, node);
      case "package":
        return visitor2.visitPackage(visitor2, node);
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "message":
      case "enum":
      case "extend":
      case "service":
        return visitor2.visitTopLevelDef(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitSyntax(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitToken(visitor2, node.quoteOpen);
      visitor2.visitToken(visitor2, node.syntax);
      visitor2.visitToken(visitor2, node.quoteClose);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitImport(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      node.weakOrPublic && visitor2.visitToken(visitor2, node.weakOrPublic);
      visitor2.visitStrLit(visitor2, node.strLit);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitPackage(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitFullIdent(visitor2, node.fullIdent);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitOption(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitOptionName(visitor2, node.optionName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitConstant(visitor2, node.constant);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitOptionName(visitor2, node) {
    for (const optionNameSegmentOrDot of node.optionNameSegmentOrDots) {
      switch (optionNameSegmentOrDot.type) {
        case "option-name-segment":
          visitor2.visitOptionNameSegment(visitor2, optionNameSegmentOrDot);
          continue;
        case "dot":
          visitor2.visitDot(visitor2, optionNameSegmentOrDot);
          continue;
      }
    }
  },
  visitOptionNameSegment(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    visitor2.visitFullIdent(visitor2, node.name);
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitTopLevelDef(visitor2, node) {
    switch (node.type) {
      case "message":
        return visitor2.visitMessage(visitor2, node);
      case "enum":
        return visitor2.visitEnum(visitor2, node);
      case "extend":
        return visitor2.visitExtend(visitor2, node);
      case "service":
        return visitor2.visitService(visitor2, node);
    }
  },
  visitMessage(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.messageName);
      visitor2.visitMessageBody(visitor2, node.messageBody);
    });
  },
  visitMessageBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitMessageBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitMessageBodyStatement(visitor2, node) {
    switch (node.type) {
      case "field":
        return visitor2.visitField(visitor2, node);
      case "malformed-field":
        return visitor2.visitMalformedField(visitor2, node);
      case "enum":
        return visitor2.visitEnum(visitor2, node);
      case "message":
        return visitor2.visitMessage(visitor2, node);
      case "extend":
        return visitor2.visitExtend(visitor2, node);
      case "extensions":
        return visitor2.visitExtensions(visitor2, node);
      case "group":
        return visitor2.visitGroup(visitor2, node);
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "oneof":
        return visitor2.visitOneof(visitor2, node);
      case "map-field":
        return visitor2.visitMapField(visitor2, node);
      case "reserved":
        return visitor2.visitReserved(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitEnum(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.enumName);
      visitor2.visitEnumBody(visitor2, node.enumBody);
    });
  },
  visitEnumBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitEnumBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitEnumBodyStatement(visitor2, node) {
    switch (node.type) {
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "reserved":
        return visitor2.visitReserved(visitor2, node);
      case "enum-field":
        return visitor2.visitEnumField(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitEnumField(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitToken(visitor2, node.fieldName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitSignedIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitExtend(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitType(visitor2, node.messageType);
      visitor2.visitExtendBody(visitor2, node.extendBody);
    });
  },
  visitExtendBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitExtendBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitExtendBodyStatement(visitor2, node) {
    switch (node.type) {
      case "field":
        return visitor2.visitField(visitor2, node);
      case "group":
        return visitor2.visitGroup(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitService(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.serviceName);
      visitor2.visitServiceBody(visitor2, node.serviceBody);
    });
  },
  visitServiceBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitServiceBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitServiceBodyStatement(visitor2, node) {
    switch (node.type) {
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "rpc":
        return visitor2.visitRpc(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitRpc(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.rpcName);
      visitor2.visitRpcType(visitor2, node.reqType);
      visitor2.visitToken(visitor2, node.returns);
      visitor2.visitRpcType(visitor2, node.resType);
      if (node.semiOrRpcBody.type === "semi") {
        visitor2.visitSemi(visitor2, node.semiOrRpcBody);
      } else {
        visitor2.visitRpcBody(visitor2, node.semiOrRpcBody);
      }
    });
  },
  visitRpcBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitRpcBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitRpcBodyStatement(visitor2, node) {
    switch (node.type) {
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitRpcType(visitor2, node) {
    visitor2.visitToken(visitor2, node.bracketOpen);
    node.stream && visitor2.visitKeyword(visitor2, node.stream);
    visitor2.visitType(visitor2, node.messageType);
    visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitEmpty(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitField(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      node.fieldLabel && visitor2.visitKeyword(visitor2, node.fieldLabel);
      visitor2.visitType(visitor2, node.fieldType);
      visitor2.visitToken(visitor2, node.fieldName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitFieldOptions(visitor2, node) {
    visitor2.visitToken(visitor2, node.bracketOpen);
    for (const fieldOptionOrComma of node.fieldOptionOrCommas) {
      switch (fieldOptionOrComma.type) {
        case "field-option":
          visitor2.visitFieldOption(visitor2, fieldOptionOrComma);
          continue;
        case "comma":
          visitor2.visitComma(visitor2, fieldOptionOrComma);
          continue;
      }
    }
    visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitFieldOption(visitor2, node) {
    visitor2.visitOptionName(visitor2, node.optionName);
    visitor2.visitToken(visitor2, node.eq);
    visitor2.visitConstant(visitor2, node.constant);
  },
  visitGroup(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.groupLabel);
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.groupName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      visitor2.visitMessageBody(visitor2, node.messageBody);
    });
  },
  visitOneof(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.oneofName);
      visitor2.visitOneofBody(visitor2, node.oneofBody);
    });
  },
  visitOneofBody(visitor2, node) {
    node.bracketOpen && visitor2.visitToken(visitor2, node.bracketOpen);
    for (const statement of node.statements) {
      visitor2.visitOneofBodyStatement(visitor2, statement);
    }
    node.bracketClose && visitor2.visitToken(visitor2, node.bracketClose);
  },
  visitOneofBodyStatement(visitor2, node) {
    switch (node.type) {
      case "option":
        return visitor2.visitOption(visitor2, node);
      case "oneof-field":
        return visitor2.visitOneofField(visitor2, node);
      case "empty":
        return visitor2.visitEmpty(visitor2, node);
    }
  },
  visitOneofField(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitType(visitor2, node.fieldType);
      visitor2.visitToken(visitor2, node.fieldName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitOneofGroup(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.groupName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitIntLit(visitor2, node.fieldNumber);
      visitor2.visitMessageBody(visitor2, node.messageBody);
    });
  },
  visitMalformedField(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      node.fieldLabel && visitor2.visitKeyword(visitor2, node.fieldLabel);
      visitor2.visitType(visitor2, node.fieldType);
      node.fieldName && visitor2.visitToken(visitor2, node.fieldName);
      node.eq && visitor2.visitToken(visitor2, node.eq);
      node.fieldNumber && visitor2.visitIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      node.semi && visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitMapField(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitToken(visitor2, node.typeBracketOpen);
      visitor2.visitType(visitor2, node.keyType);
      visitor2.visitToken(visitor2, node.typeSep);
      visitor2.visitType(visitor2, node.valueType);
      visitor2.visitToken(visitor2, node.typeBracketClose);
      visitor2.visitToken(visitor2, node.mapName);
      visitor2.visitToken(visitor2, node.eq);
      visitor2.visitIntLit(visitor2, node.fieldNumber);
      node.fieldOptions && visitor2.visitFieldOptions(visitor2, node.fieldOptions);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitExtensions(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      visitor2.visitRanges(visitor2, node.ranges);
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitRanges(visitor2, node) {
    for (const rangeOrComma of node.rangeOrCommas) {
      switch (rangeOrComma.type) {
        case "range":
          visitor2.visitRange(visitor2, rangeOrComma);
          continue;
        case "comma":
          visitor2.visitComma(visitor2, rangeOrComma);
          continue;
      }
    }
  },
  visitRange(visitor2, node) {
    visitor2.visitIntLit(visitor2, node.rangeStart);
    node.to && visitor2.visitKeyword(visitor2, node.to);
    if (node.rangeEnd) {
      switch (node.rangeEnd.type) {
        case "int-lit":
          visitor2.visitIntLit(visitor2, node.rangeEnd);
          break;
        case "max":
          visitor2.visitMax(visitor2, node.rangeEnd);
          break;
      }
    }
  },
  visitMax(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitReserved(visitor2, node) {
    visitStatementBase(visitor2, node, () => {
      visitor2.visitKeyword(visitor2, node.keyword);
      switch (node.reserved.type) {
        case "ranges":
          visitor2.visitRanges(visitor2, node.reserved);
          break;
        case "field-names":
          visitor2.visitFieldNames(visitor2, node.reserved);
          break;
      }
      visitor2.visitSemi(visitor2, node.semi);
    });
  },
  visitFieldNames(visitor2, node) {
    for (const strLitOrComma of node.strLitOrCommas) {
      switch (strLitOrComma.type) {
        case "str-lit":
          visitor2.visitStrLit(visitor2, strLitOrComma);
          continue;
        case "comma":
          visitor2.visitComma(visitor2, strLitOrComma);
          continue;
      }
    }
  },
  visitConstant(visitor2, node) {
    switch (node.type) {
      case "full-ident":
        return visitor2.visitFullIdent(visitor2, node);
      case "signed-int-lit":
        return visitor2.visitSignedIntLit(visitor2, node);
      case "signed-float-lit":
        return visitor2.visitSignedFloatLit(visitor2, node);
      case "str-lit":
        return visitor2.visitStrLit(visitor2, node);
      case "bool-lit":
        return visitor2.visitBoolLit(visitor2, node);
      case "aggregate":
        return visitor2.visitAggregate(visitor2, node);
    }
  },
  visitCommentGroup(visitor2, node) {
    for (const comment of node.comments) {
      visitor2.visitComment(visitor2, comment);
    }
  },
  visitComment(visitor2, node) {
    switch (node.type) {
      case "singleline-comment":
        return visitor2.visitSinglelineComment(visitor2, node);
      case "multiline-comment":
        return visitor2.visitMultilineComment(visitor2, node);
    }
  },
  visitSinglelineComment(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitMultilineComment(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitKeyword(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitType(visitor2, node) {
    for (const identOrDot of node.identOrDots) {
      switch (identOrDot.type) {
        case "ident":
          visitor2.visitIdent(visitor2, identOrDot);
          continue;
        case "dot":
          visitor2.visitDot(visitor2, identOrDot);
          continue;
      }
    }
  },
  visitFullIdent(visitor2, node) {
    for (const identOrDot of node.identOrDots) {
      switch (identOrDot.type) {
        case "ident":
          visitor2.visitIdent(visitor2, identOrDot);
          continue;
        case "dot":
          visitor2.visitDot(visitor2, identOrDot);
          continue;
      }
    }
  },
  visitIntLit(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitSignedIntLit(visitor2, node) {
    node.sign && visitor2.visitToken(visitor2, node.sign);
    visitor2.visitIntLit(visitor2, node.value);
  },
  visitFloatLit(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitSignedFloatLit(visitor2, node) {
    node.sign && visitor2.visitToken(visitor2, node.sign);
    visitor2.visitFloatLit(visitor2, node.value);
  },
  visitStrLit(visitor2, node) {
    for (const token of node.tokens) {
      visitor2.visitToken(visitor2, token);
    }
  },
  visitBoolLit(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitAggregate() {
  },
  visitIdent(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitDot(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitComma(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitSemi(visitor2, node) {
    visitor2.visitToken(visitor2, node);
  },
  visitToken() {
  }
};
function visitStatementBase(visitor2, node, visit) {
  for (const commentGroup of node.leadingDetachedComments) {
    visitor2.visitCommentGroup(visitor2, commentGroup);
  }
  for (const commentGroup of node.leadingComments) {
    visitor2.visitCommentGroup(visitor2, commentGroup);
  }
  visit();
  for (const commentGroup of node.trailingComments) {
    visitor2.visitCommentGroup(visitor2, commentGroup);
  }
}

// deno:file:///home/runner/work/pbkit/pbkit/core/schema/stringify-ast-frag.ts
function createNaiveAstStringifier() {
  const result = [];
  const visitor2 = __spreadProps(__spreadValues({}, visitor), {
    visitComment() {
    },
    visitToken(_, node) {
      result.push(node.text);
    }
  });
  return { visitor: visitor2, finish: () => result.join("") };
}
function stringifyType(type) {
  const stringifier = createNaiveAstStringifier();
  stringifier.visitor.visitType(stringifier.visitor, type);
  return stringifier.finish();
}
function stringifyFullIdent(fullIdent) {
  const stringifier = createNaiveAstStringifier();
  stringifier.visitor.visitFullIdent(stringifier.visitor, fullIdent);
  return stringifier.finish();
}
function stringifyOptionName(optionName) {
  const stringifier = createNaiveAstStringifier();
  stringifier.visitor.visitOptionName(stringifier.visitor, optionName);
  return stringifier.finish();
}

// deno:file:///home/runner/work/pbkit/pbkit/core/schema/eval-ast-constant.ts
function evalConstant(constant) {
  switch (constant.type) {
    case "aggregate":
      return "";
    case "bool-lit":
      return evalBoolLit(constant.text);
    case "full-ident":
      return stringifyFullIdent(constant);
    case "signed-float-lit":
      return evalSignedFloatLit(constant);
    case "signed-int-lit":
      return evalSignedIntLit(constant);
    case "str-lit":
      return evalStrLit(constant);
  }
}
function evalBoolLit(text) {
  if (text === "true")
    return true;
  return false;
}
function evalIntLit(intLit) {
  const text = intLit.text;
  if (text.startsWith("0x"))
    return parseInt(text, 16);
  if (text.startsWith("0"))
    return parseInt(text, 8);
  return parseInt(text, 10);
}
function evalSignedIntLit(signedIntLit) {
  var _a;
  const intLit = signedIntLit.value;
  if (((_a = signedIntLit.sign) == null ? void 0 : _a.text) === "-")
    return -evalIntLit(intLit);
  return evalIntLit(intLit);
}
function evalFloatLit(floatLit) {
  const text = floatLit.text;
  if (text === "inf")
    return Infinity;
  if (text === "nan")
    return NaN;
  return parseFloat(text);
}
function evalSignedFloatLit(signedFloatLit) {
  var _a;
  const floatLit = signedFloatLit.value;
  if (((_a = signedFloatLit.sign) == null ? void 0 : _a.text) === "-")
    return -evalFloatLit(floatLit);
  return evalFloatLit(floatLit);
}
function evalStrLit(strLit) {
  return strLit.tokens.map((token) => evalStrLitFragment(token.text)).join("");
}
function evalStrLitFragment(text) {
  return text.slice(1, -1).replace(/(?:\\x([0-9a-f]{2})|\\([0-7]{3})|\\([0abfnrtv\\'"]))/i, (input, hex, octal, char) => {
    if (hex)
      return String.fromCodePoint(parseInt(hex, 16));
    if (octal)
      return String.fromCharCode(parseInt(octal, 8) % 256);
    if (char)
      return charMap[char.toLowerCase()];
    return input;
  });
}
var charMap = {
  "0": "\0",
  "a": "\x07",
  "b": "\b",
  "f": "\f",
  "n": "\n",
  "r": "\r",
  "t": "	",
  "v": "\v",
  "\\": "\\",
  "'": "'",
  '"': '"'
};

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/scalar.ts
var _scalarValueTypes = [
  "double",
  "float",
  "int32",
  "int64",
  "uint32",
  "uint64",
  "sint32",
  "sint64",
  "fixed32",
  "fixed64",
  "sfixed32",
  "sfixed64",
  "bool",
  "string",
  "bytes"
];
var scalarValueTypes = _scalarValueTypes;

// deno:file:///home/runner/work/pbkit/pbkit/core/schema/builder.ts
async function build(config) {
  return connect(await extract(gather(config)));
}
async function extract(files) {
  const result = {
    files: {},
    types: {},
    extends: {},
    services: {}
  };
  for await (const { filePath, parseResult, file: file2 } of files) {
    result.files[filePath] = file2;
    const typePath = file2.package ? "." + file2.package : "";
    const statements = parseResult.ast.statements;
    const services = iterServices(statements, typePath, filePath);
    for (const [typePath2, service] of services) {
      file2.servicePaths.push(typePath2);
      if (!(typePath2 in result.services))
        result.services[typePath2] = service;
    }
    const types = iterTypes(statements, typePath, filePath);
    for (const [typePath2, type] of types) {
      file2.typePaths.push(typePath2);
      if (!(typePath2 in result.types))
        result.types[typePath2] = type;
    }
  }
  return result;
}
function connect(schema) {
  const importPathToFilePath = {};
  for (const [filePath, { importPath }] of Object.entries(schema.files)) {
    if (importPath in importPathToFilePath)
      continue;
    importPathToFilePath[importPath] = filePath;
  }
  for (const file2 of Object.values(schema.files)) {
    for (const entry of file2.imports) {
      if (entry.importPath in importPathToFilePath) {
        entry.filePath = importPathToFilePath[entry.importPath];
      }
    }
  }
  for (const [filePath, file2] of Object.entries(schema.files)) {
    const resolveTypePath = getResolveTypePathFn(schema, filePath);
    for (const typePath of file2.typePaths) {
      const type = schema.types[typePath];
      if (type.kind === "enum")
        continue;
      for (const field of Object.values(type.fields)) {
        if (field.kind === "map") {
          const fieldKeyTypePath = resolveTypePath(field.keyType, typePath);
          const fieldValueTypePath = resolveTypePath(field.valueType, typePath);
          if (fieldKeyTypePath)
            field.keyTypePath = fieldKeyTypePath;
          if (fieldValueTypePath)
            field.valueTypePath = fieldValueTypePath;
        } else {
          const fieldTypePath = resolveTypePath(field.type, typePath);
          if (fieldTypePath)
            field.typePath = fieldTypePath;
        }
      }
    }
    for (const servicePath of file2.servicePaths) {
      const service = schema.services[servicePath];
      for (const rpc of Object.values(service.rpcs)) {
        const reqTypePath = resolveTypePath(rpc.reqType.type, servicePath);
        const resTypePath = resolveTypePath(rpc.resType.type, servicePath);
        if (reqTypePath)
          rpc.reqType.typePath = reqTypePath;
        if (resTypePath)
          rpc.resType.typePath = resTypePath;
      }
    }
  }
  return schema;
}
async function* gather({ files, loader }) {
  const queue = [...files];
  const visited = {};
  const loaded = {};
  while (queue.length) {
    const importPath = queue.pop();
    if (visited[importPath])
      continue;
    visited[importPath] = true;
    const loadResult = await loader.load(importPath);
    if (!loadResult)
      continue;
    if (loaded[loadResult.absolutePath])
      continue;
    loaded[loadResult.absolutePath] = true;
    const parseResult = parse2(loadResult.data);
    const statements = parseResult.ast.statements;
    const file2 = {
      parseResult,
      importPath,
      syntax: getSyntax(statements),
      package: getPackage(statements),
      imports: getImports(statements),
      options: getOptions(statements),
      typePaths: [],
      servicePaths: []
    };
    yield { filePath: loadResult.absolutePath, parseResult, file: file2 };
    queue.push(...file2.imports.map(({ importPath: importPath2 }) => importPath2));
  }
}
function getSyntax(statements) {
  const syntaxStatement = findNodeByType(statements, "syntax");
  const syntax = syntaxStatement == null ? void 0 : syntaxStatement.syntax.text;
  return syntax === "proto3" ? "proto3" : "proto2";
}
function getPackage(statements) {
  const packageStatement = findNodeByType(statements, "package");
  if (!packageStatement)
    return "";
  return stringifyFullIdent(packageStatement.fullIdent);
}
function getImports(statements) {
  const importStatements = filterNodesByType(statements, "import");
  return importStatements.map((statement) => {
    var _a;
    const kind = ((_a = statement.weakOrPublic) == null ? void 0 : _a.text) || "";
    const importPath = evalStrLit(statement.strLit);
    return {
      kind,
      importPath
    };
  });
}
function getOptions(nodes) {
  if (!nodes)
    return {};
  const optionStatements = filterNodesByTypes(nodes, [
    "option",
    "field-option"
  ]);
  const result = {};
  for (const statement of optionStatements) {
    const optionName = stringifyOptionName(statement.optionName);
    const optionValue = evalConstant(statement.constant);
    result[optionName] = optionValue;
  }
  return result;
}
function* iterServices(statements, typePath, filePath) {
  const serviceStatements = filterNodesByType(statements, "service");
  for (const statement of serviceStatements) {
    const serviceTypePath = typePath + "." + statement.serviceName.text;
    const service = {
      filePath,
      options: getOptions(statement.serviceBody.statements),
      description: getDescription(statement),
      rpcs: getRpcs(statement.serviceBody.statements)
    };
    yield [serviceTypePath, service];
  }
}
function getRpcs(statements) {
  const rpcStatements = filterNodesByType(statements, "rpc");
  const rpcs = {};
  for (const statement of rpcStatements) {
    const options = statement.semiOrRpcBody.type === "rpc-body" ? getOptions(statement.semiOrRpcBody.statements) : {};
    rpcs[statement.rpcName.text] = {
      options,
      description: getDescription(statement),
      reqType: getRpcType(statement.reqType),
      resType: getRpcType(statement.resType)
    };
  }
  return rpcs;
}
function getRpcType(rpcType) {
  return {
    stream: !!rpcType.stream,
    type: stringifyType(rpcType.messageType)
  };
}
function* iterTypes(statements, typePath, filePath) {
  for (const statement of statements) {
    if (statement.type === "enum") {
      yield getEnum(statement, typePath, filePath);
    } else if (statement.type === "message") {
      const message = getMessage(statement, typePath, filePath);
      yield message;
      const messageBodyStatement = statement.messageBody.statements;
      yield* iterTypes(messageBodyStatement, message[0], filePath);
    }
  }
}
function getMessage(statement, typePath, filePath) {
  const messageTypePath = typePath + "." + statement.messageName.text;
  const statements = statement.messageBody.statements;
  const message = __spreadValues({
    kind: "message",
    filePath,
    description: getDescription(statement)
  }, getMessageBody(statements));
  return [messageTypePath, message];
}
function getMessageBody(statements) {
  const fields = {};
  for (const [fieldNumber, field] of iterMessageFields(statements)) {
    fields[fieldNumber] = field;
  }
  const groups = {};
  for (const groupStatement of filterNodesByType(statements, "group")) {
    const groupName = groupStatement.groupName.text;
    groups[groupName] = getGroup(groupStatement);
  }
  return {
    options: getOptions(statements),
    fields,
    groups,
    reservedFieldNumberRanges: [],
    reservedFieldNames: [],
    extensions: []
  };
}
function* iterMessageFields(statements) {
  var _a, _b;
  for (const statement of statements) {
    if (statement.type === "field") {
      const fieldNumber = evalIntLit(statement.fieldNumber);
      const fieldBase = {
        description: getDescription(statement),
        name: statement.fieldName.text,
        options: getOptions((_a = statement.fieldOptions) == null ? void 0 : _a.fieldOptionOrCommas),
        type: stringifyType(statement.fieldType)
      };
      if (!statement.fieldLabel) {
        yield [fieldNumber, __spreadValues({ kind: "normal" }, fieldBase)];
      } else {
        const kind = statement.fieldLabel.text;
        if (kind === "required" || kind === "optional" || kind === "repeated") {
          yield [fieldNumber, __spreadValues({ kind }, fieldBase)];
        }
      }
    } else if (statement.type === "oneof") {
      yield* iterOneofFields(statement.oneofBody.statements, statement.oneofName.text);
    } else if (statement.type === "map-field") {
      yield [evalIntLit(statement.fieldNumber), {
        kind: "map",
        description: getDescription(statement),
        name: statement.mapName.text,
        options: getOptions((_b = statement.fieldOptions) == null ? void 0 : _b.fieldOptionOrCommas),
        keyType: stringifyType(statement.keyType),
        valueType: stringifyType(statement.valueType)
      }];
    }
  }
}
function* iterOneofFields(statements, oneof) {
  var _a;
  const oneofStatements = filterNodesByType(statements, "oneof-field");
  for (const statement of oneofStatements) {
    const fieldNumber = evalIntLit(statement.fieldNumber);
    yield [fieldNumber, {
      kind: "oneof",
      description: getDescription(statement),
      name: statement.fieldName.text,
      options: getOptions((_a = statement.fieldOptions) == null ? void 0 : _a.fieldOptionOrCommas),
      type: stringifyType(statement.fieldType),
      oneof
    }];
  }
}
function getGroup(statement) {
  const statements = statement.messageBody.statements;
  const fields = {};
  for (const [fieldNumber, field] of iterMessageFields(statements)) {
    fields[fieldNumber] = field;
  }
  return __spreadValues({
    kind: statement.groupLabel.text,
    description: getDescription(statement),
    fieldNumber: evalIntLit(statement.fieldNumber)
  }, getMessageBody(statements));
}
function getEnum(statement, typePath, filePath) {
  const enumTypePath = typePath + "." + statement.enumName.text;
  const _enum = {
    kind: "enum",
    filePath,
    options: getOptions(statement.enumBody.statements),
    description: getDescription(statement),
    fields: getEnumFields(statement.enumBody.statements)
  };
  return [enumTypePath, _enum];
}
function getEnumFields(statements) {
  var _a;
  const fields = {};
  const enumFieldStatements = filterNodesByType(statements, "enum-field");
  for (const statement of enumFieldStatements) {
    const fieldNumber = evalSignedIntLit(statement.fieldNumber);
    fields[fieldNumber] = {
      description: getDescription(statement),
      name: statement.fieldName.text,
      options: getOptions((_a = statement.fieldOptions) == null ? void 0 : _a.fieldOptionOrCommas)
    };
  }
  return fields;
}
function getDescription(statement) {
  return {
    leading: unwrapComments(statement.leadingComments),
    trailing: unwrapComments(statement.trailingComments),
    leadingDetached: unwrapComments(statement.leadingDetachedComments)
  };
  function unwrapComments(commentGroups) {
    return commentGroups.map((commentGroup) => commentGroup.comments.map((comment) => unwrap(comment.text)).join("\n"));
  }
}
function getResolveTypePathFn(schema, filePath) {
  const visibleTypePaths = toPojoSet(getVisibleTypePaths(schema, filePath));
  return function resolveTypePath(type, scope) {
    if (type in scalarValueTypeSet)
      return "." + type;
    if (type.startsWith("."))
      return visibleTypePaths[type];
    let currentScope = scope;
    while (true) {
      const typePath = currentScope + "." + type;
      if (typePath in visibleTypePaths)
        return typePath;
      const cut = currentScope.lastIndexOf(".");
      if (cut < 0)
        return void 0;
      currentScope = currentScope.slice(0, cut);
    }
  };
}
var scalarValueTypeSet = toPojoSet(scalarValueTypes);
function getVisibleTypePaths(schema, filePath) {
  const file2 = schema.files[filePath];
  if (!file2)
    return [];
  return [
    ...file2.typePaths,
    ...file2.imports.map((entry) => entry.filePath ? getExportedTypePaths(schema, entry.filePath) : []).flat(1)
  ];
}
function getExportedTypePaths(schema, filePath) {
  const result = [];
  const done = {};
  const queue = [filePath];
  while (queue.length) {
    const filePath2 = queue.pop();
    if (done[filePath2])
      continue;
    done[filePath2] = true;
    const file2 = schema.files[filePath2];
    if (!file2)
      continue;
    result.push(...file2.typePaths);
    for (const entry of file2.imports) {
      if (entry.kind !== "public")
        continue;
      if (!entry.filePath)
        continue;
      queue.push(entry.filePath);
    }
  }
  return result;
}

// deno:https://deno.land/std@0.147.0/io/readers.ts
var StringReader = class extends Buffer2 {
  constructor(s) {
    super(new TextEncoder().encode(s).buffer);
  }
};
var _readers, _currentIndex;
var MultiReader = class {
  constructor(readers) {
    __privateAdd(this, _readers, void 0);
    __privateAdd(this, _currentIndex, 0);
    __privateSet(this, _readers, [...readers]);
  }
  async read(p) {
    const r = __privateGet(this, _readers)[__privateGet(this, _currentIndex)];
    if (!r)
      return null;
    const result = await r.read(p);
    if (result === null) {
      __privateWrapper(this, _currentIndex)._++;
      return 0;
    }
    return result;
  }
};
_readers = new WeakMap();
_currentIndex = new WeakMap();

// deno:https://deno.land/std@0.147.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE = 32 * 1024;
async function readAll(r) {
  const buf = new Buffer2();
  await buf.readFrom(r);
  return buf.bytes();
}
function readAllSync(r) {
  const buf = new Buffer2();
  buf.readFromSync(r);
  return buf.bytes();
}

// deno:https://deno.land/std@0.147.0/io/streams.ts
var readAll2 = readAll;
var readAllSync2 = readAllSync;

// deno:https://deno.land/std@0.147.0/fmt/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof (Deno2 == null ? void 0 : Deno2.noColor) === "boolean" ? Deno2.noColor : true;
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://deno.land/std@0.147.0/io/files.ts
var DEFAULT_BUFFER_SIZE2 = 32 * 1024;

// deno:https://deno.land/std@0.147.0/io/util.ts
var DEFAULT_BUFFER_SIZE3 = 32 * 1024;
var MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);

// deno:https://deno.land/std@0.147.0/io/writers.ts
var decoder = new TextDecoder();
var _chunks2, _byteLength, _cache;
var StringWriter = class {
  constructor(base = "") {
    this.base = base;
    __privateAdd(this, _chunks2, []);
    __privateAdd(this, _byteLength, 0);
    __privateAdd(this, _cache, void 0);
    const c = new TextEncoder().encode(base);
    __privateGet(this, _chunks2).push(c);
    __privateSet(this, _byteLength, __privateGet(this, _byteLength) + c.byteLength);
  }
  write(p) {
    return Promise.resolve(this.writeSync(p));
  }
  writeSync(p) {
    __privateGet(this, _chunks2).push(p);
    __privateSet(this, _byteLength, __privateGet(this, _byteLength) + p.byteLength);
    __privateSet(this, _cache, void 0);
    return p.byteLength;
  }
  toString() {
    if (__privateGet(this, _cache)) {
      return __privateGet(this, _cache);
    }
    const buf = new Uint8Array(__privateGet(this, _byteLength));
    let offs = 0;
    for (const chunk of __privateGet(this, _chunks2)) {
      buf.set(chunk, offs);
      offs += chunk.byteLength;
    }
    __privateSet(this, _cache, decoder.decode(buf));
    return __privateGet(this, _cache);
  }
};
_chunks2 = new WeakMap();
_byteLength = new WeakMap();
_cache = new WeakMap();

// deno:file:///home/runner/work/pbkit/pbkit/misc/compat/tsc.ts
function replaceTsFileExtensionInImportStatement(code, extension) {
  if (extension === ".ts")
    return code;
  return code.replaceAll(/(^\s*(?:import|export|}\s*from)\b.+?)\.ts("|')/gm, `$1${extension}$2`);
}
async function replaceTsFileExtensionInImportStatementFromReader(reader, extension) {
  const data = "readSync" in reader ? readAllSync2(reader) : await readAll2(reader);
  return new StringReader(replaceTsFileExtensionInImportStatement(new TextDecoder().decode(data), extension));
}

// deno:https://deno.land/std@0.147.0/path/_constants.ts
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;

// deno:https://deno.land/std@0.147.0/path/_util.ts
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
  }
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0, len = path.length; i <= len; ++i) {
    if (i < len)
      code = path.charCodeAt(i);
    else if (isPathSeparator(code))
      break;
    else
      code = CHAR_FORWARD_SLASH;
    if (isPathSeparator(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/path.ts
var CHAR_FORWARD_SLASH2 = 47;
function relative(from, to) {
  assertPath(from);
  assertPath(to);
  from = normalize(from);
  to = normalize(to);
  if (from === to)
    return "";
  const fromFragments = from.split("/").filter(Boolean);
  const toFragments = to.split("/").filter(Boolean);
  while (fromFragments.length && toFragments.length) {
    if (fromFragments[0] !== toFragments[0])
      break;
    fromFragments.shift();
    toFragments.shift();
  }
  return [...fromFragments.map(() => ".."), ...toFragments].join("/");
}
function dirname(path) {
  assertPath(path);
  if (path.length === 0)
    return ".";
  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  let end = -1;
  let matchedSlash = true;
  for (let i = path.length - 1; i >= 1; --i) {
    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH2) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path.slice(0, end);
}
var protocolRegex = /^\w+:\/\//;
function join(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path = paths[i];
    assertPath(path);
    if (path.length > 0) {
      if (!joined)
        joined = path;
      else
        joined += `/${path}`;
    }
  }
  if (!joined)
    return ".";
  if (protocolRegex.test(joined)) {
    let protocol;
    const normalized = normalize(joined.replace(protocolRegex, (p) => (protocol = p, "")));
    return protocol + normalized;
  }
  return normalize(joined);
}
function normalize(path) {
  assertPath(path);
  if (path.length === 0)
    return ".";
  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH2;
  path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
  if (path.length === 0 && !isAbsolute)
    path = ".";
  if (path.length > 0 && trailingSeparator)
    path += "/";
  if (isAbsolute)
    return `/${path}`;
  return path;
}

// deno:file:///home/runner/work/pbkit/pbkit/misc/case.ts
function snakeToCamel(snake) {
  return snake.replace(snakeToCamelRegex, snakeToCamelReplaceFn);
}
function pascalToCamel(pascal) {
  return pascal[0].toLowerCase() + pascal.slice(1);
}
var id = (x) => x;
var capitalize = (word) => word[0].toUpperCase() + word.slice(1);
var snakeToCamelRegex = /^(_*)(.*?)(_*)$/;
var snakeToCamelReplaceFn = (...args) => {
  const [, $1, $2, $3] = args;
  const [head, ...rest] = $2.split("_");
  return `${$1}${head + rest.filter(id).map(capitalize).join("")}${$3}`;
};

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/Long.ts
var UINT16_MAX = 65535;
var UINT32_MAX = 4294967295;
var Long = class extends Uint32Array {
  constructor(lo = 0, hi = 0) {
    super([lo, hi]);
  }
  toString(signed = true) {
    const [lo, hi] = this;
    if (lo === 0 && hi === 0)
      return "0";
    if (signed && hi > 2147483647) {
      return "-" + add(negate(this), one).toString(false);
    }
    const result = [];
    let tmp = new Long(lo, hi);
    while (compare(tmp, zero)) {
      const [next, remainder] = divByTen(tmp);
      result.push(remainder);
      tmp = next;
    }
    return result.reverse().join("");
  }
  static parse(text) {
    const parsedValue = parseInt(text, 10);
    const sign = parsedValue < 0;
    if (Number.isNaN(parsedValue))
      return new Long(0);
    if (text.length < 10) {
      if (parsedValue < 0)
        return add(negate(new Long(-parsedValue)), one);
      return new Long(parsedValue);
    }
    let result = new Long();
    let powerTen = one;
    for (const digit of text.split("").reverse()) {
      if (parseInt(digit)) {
        result = add(result, mul(new Long(parseInt(digit)), powerTen));
      }
      powerTen = mul(powerTen, new Long(10));
    }
    if (!sign)
      return result;
    return add(negate(result), one);
  }
};
var zero = new Long(0);
var one = new Long(1);
function makeChunk(value) {
  const [lo, hi] = value;
  return [lo & UINT16_MAX, lo >>> 16, hi & UINT16_MAX, hi >>> 16];
}
function add(a, b) {
  const [a00, a16, a32, a48] = makeChunk(a);
  const [b00, b16, b32, b48] = makeChunk(b);
  let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= UINT16_MAX;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= UINT16_MAX;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= UINT16_MAX;
  c48 += a48 + b48;
  c48 &= UINT16_MAX;
  return new Long(c16 << 16 | c00, c48 << 16 | c32);
}
function mul(a, b) {
  const [a00, a16, a32, a48] = makeChunk(a);
  const [b00, b16, b32, b48] = makeChunk(b);
  let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= UINT16_MAX;
  c16 += a00 * b16 + a16 * b00;
  c32 += c16 >>> 16;
  c16 &= UINT16_MAX;
  c32 += a00 * b32 + a32 * b00 + a16 * b16;
  c48 += c32 >>> 16;
  c32 &= UINT16_MAX;
  c48 += a00 * b48 + a16 * b32 + a32 * b16 + a48 * b00;
  c48 &= UINT16_MAX;
  return new Long(c16 << 16 | c00, c48 << 16 | c32);
}
function divByTen(value) {
  const [lo, hi] = value;
  return [
    new Long((hi % 10 * (UINT32_MAX + 1) + lo) / 10 | 0, hi / 10 | 0),
    (hi % 10 * (UINT32_MAX + 1) + lo) % 10
  ];
}
function compare(a, b) {
  const [l1, h1] = a;
  const [l2, h2] = b;
  if (h1 !== h2)
    return h1 - h2;
  return l1 - l2;
}
function negate(value) {
  const [lo, hi] = value;
  return new Long(~lo, ~hi);
}

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/wire/varint.ts
function encode(value) {
  const result = [];
  const mask = 127;
  const head = 1 << 7;
  let long = typeof value === "number" ? new Long(value) : value;
  while (long[0] || long[1]) {
    const [lo, hi] = long;
    const chunk = lo & mask;
    const nextHi = hi >>> 7;
    const nextLo = lo >>> 7 | (hi & mask) << 32 - 7;
    long = new Long(nextLo, nextHi);
    const resultChunk = !(long[0] || long[1]) ? chunk : chunk | head;
    result.push(resultChunk);
  }
  if (result.length < 1)
    return new Uint8Array(1);
  return Uint8Array.from(result);
}
function decode(dataview) {
  let result = new Long(0);
  let i = 0;
  while (true) {
    const curr = dataview.getUint8(i);
    result = or(result, leftshift(new Long(curr & 127), i * 7));
    ++i;
    if (curr >>> 7)
      continue;
    return [i, result];
  }
}
function or(a, b) {
  return new Long(a[0] | b[0], a[1] | b[1]);
}
function leftshift(a, count) {
  if (count === 0)
    return a;
  if (count >= 32)
    return new Long(0, a[0] << count - 32);
  return new Long(a[0] << count, a[1] << count | a[0] >>> 32 - count);
}

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/wire/zigzag.ts
function encode2(value) {
  if (value instanceof Long) {
    const l = new Long(value[0] << 1, value[1] << 1 | value[0] >>> 31);
    const r = value[1] >>> 31 ? new Long(4294967295, 4294967295) : new Long();
    return new Long(l[0] ^ r[0], l[1] ^ r[1]);
  }
  return (value * 2 ^ value >> 31) >>> 0;
}
function decode2(value) {
  if (value instanceof Long) {
    const l = new Long(value[0] >>> 1 | value[1] << 31, value[1] >>> 1);
    const r = value[0] & 1 ? new Long(4294967295, 4294967295) : new Long();
    return new Long(l[0] ^ r[0], l[1] ^ r[1]);
  }
  return value >>> 1 ^ -(value & 1);
}

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/wire/serialize.ts
function concat2(arrays) {
  const totalLength = arrays.reduce((acc, value) => {
    return acc + value.byteLength;
  }, 0);
  const result = new Uint8Array(totalLength);
  arrays.reduce((acc, array) => {
    result.set(array, acc);
    return acc + array.byteLength;
  }, 0);
  return result;
}

// deno:file:///home/runner/work/pbkit/pbkit/core/runtime/wire/scalar.ts
var decodeVarintFns = {
  int32: (long) => long[0] | 0,
  int64: (long) => long.toString(true),
  uint32: (long) => long[0] >>> 0,
  uint64: (long) => long.toString(false),
  sint32: (long) => decode2(long[0]),
  sint64: (long) => decode2(long).toString(true),
  bool: (long) => long[0] !== 0
};
var encodeVarintFns = {
  int32: (tsValue) => new Long(tsValue),
  int64: (tsValue) => Long.parse(tsValue),
  uint32: (tsValue) => new Long(tsValue),
  uint64: (tsValue) => Long.parse(tsValue),
  sint32: (tsValue) => encode2(new Long(tsValue)),
  sint64: (tsValue) => encode2(Long.parse(tsValue)),
  bool: (tsValue) => new Long(+tsValue)
};
var varintFieldToTsValueFns = Object.fromEntries(Object.entries(decodeVarintFns).map(([type, fn]) => [
  type,
  (wireValue) => {
    if (wireValue.type !== 0 /* Varint */)
      return;
    return fn(wireValue.value);
  }
]));
var tsValueToVarintFieldFns = Object.fromEntries(Object.entries(encodeVarintFns).map(([type, fn]) => [
  type,
  (tsValue) => ({
    type: 0 /* Varint */,
    value: fn(tsValue)
  })
]));
var wireValueToTsValueFns = __spreadProps(__spreadValues({}, varintFieldToTsValueFns), {
  double: (wireValue) => {
    if (wireValue.type !== 1 /* Fixed64 */)
      return;
    const dataview = new DataView(wireValue.value.buffer);
    return dataview.getFloat64(0, true);
  },
  float: (wireValue) => {
    if (wireValue.type !== 5 /* Fixed32 */)
      return;
    const dataview = new DataView(new Uint32Array([wireValue.value]).buffer);
    return dataview.getFloat32(0, true);
  },
  fixed32: (wireValue) => {
    if (wireValue.type !== 5 /* Fixed32 */)
      return;
    return wireValue.value >>> 0;
  },
  fixed64: (wireValue) => {
    if (wireValue.type !== 1 /* Fixed64 */)
      return;
    return wireValue.value.toString(false);
  },
  sfixed32: (wireValue) => {
    if (wireValue.type !== 5 /* Fixed32 */)
      return;
    return wireValue.value | 0;
  },
  sfixed64: (wireValue) => {
    if (wireValue.type !== 1 /* Fixed64 */)
      return;
    return wireValue.value.toString(true);
  },
  string: (wireValue) => {
    if (wireValue.type !== 2 /* LengthDelimited */)
      return;
    const textDecoder = new TextDecoder();
    return textDecoder.decode(wireValue.value);
  },
  bytes: (wireValue) => {
    if (wireValue.type !== 2 /* LengthDelimited */)
      return;
    return wireValue.value;
  }
});
var tsValueToWireValueFns = __spreadProps(__spreadValues({}, tsValueToVarintFieldFns), {
  double: (tsValue) => {
    const long = new Long();
    const dataview = new DataView(long.buffer);
    dataview.setFloat64(0, tsValue, true);
    return { type: 1 /* Fixed64 */, value: long };
  },
  float: (tsValue) => {
    const u32 = new Uint32Array(1);
    const dataview = new DataView(u32.buffer);
    dataview.setFloat32(0, tsValue, true);
    return { type: 5 /* Fixed32 */, value: dataview.getUint32(0, true) };
  },
  fixed32: (tsValue) => ({ type: 5 /* Fixed32 */, value: tsValue >>> 0 }),
  fixed64: (tsValue) => ({
    type: 1 /* Fixed64 */,
    value: Long.parse(tsValue)
  }),
  sfixed32: (tsValue) => ({ type: 5 /* Fixed32 */, value: tsValue | 0 }),
  sfixed64: (tsValue) => ({
    type: 1 /* Fixed64 */,
    value: Long.parse(tsValue)
  }),
  string: (tsValue) => {
    const textEncoder = new TextEncoder();
    return {
      type: 2 /* LengthDelimited */,
      value: textEncoder.encode(tsValue)
    };
  },
  bytes: (tsValue) => ({ type: 2 /* LengthDelimited */, value: tsValue })
});
var unpackVarintFns = Object.fromEntries(Object.keys(decodeVarintFns).map((type) => [
  type,
  function* (wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns[type](wireValue);
      if (value != null)
        yield value;
      else {
        for (const long of unpackVarint(wireValue)) {
          yield decodeVarintFns[type](long);
        }
      }
    }
  }
]));
var unpackFns = __spreadProps(__spreadValues({}, unpackVarintFns), {
  *double(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.double(wireValue);
      if (value != null)
        yield value;
      else
        yield* unpackDouble(wireValue);
    }
  },
  *float(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.float(wireValue);
      if (value != null)
        yield value;
      else
        yield* unpackFloat(wireValue);
    }
  },
  *fixed32(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.fixed32(wireValue);
      if (value != null)
        yield value;
      else
        for (const value2 of unpackFixed32(wireValue))
          yield value2 >>> 0;
    }
  },
  *fixed64(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.fixed64(wireValue);
      if (value != null)
        yield value;
      else {
        for (const value2 of unpackFixed64(wireValue)) {
          yield value2.toString(false);
        }
      }
    }
  },
  *sfixed32(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.sfixed32(wireValue);
      if (value != null)
        yield value;
      else
        for (const value2 of unpackFixed32(wireValue))
          yield value2 | 0;
    }
  },
  *sfixed64(wireValues) {
    for (const wireValue of wireValues) {
      const value = wireValueToTsValueFns.sfixed64(wireValue);
      if (value != null)
        yield value;
      else {
        for (const value2 of unpackFixed64(wireValue)) {
          yield value2.toString(true);
        }
      }
    }
  }
});
var packVarintFns = Object.fromEntries(Object.keys(encodeVarintFns).map((type) => [
  type,
  function(tsValues) {
    return {
      type: 2 /* LengthDelimited */,
      value: concat2(tsValues.map((tsValue) => {
        const value = encodeVarintFns[type](tsValue);
        return encode(value);
      }))
    };
  }
]));
function getFixedPackFn(size, setFn) {
  return function pack(values) {
    const value = new Uint8Array(values.length * size);
    const dataview = new DataView(value.buffer);
    for (let i = 0; i < values.length; ++i) {
      setFn(dataview, i * size, values[i]);
    }
    return { type: 2 /* LengthDelimited */, value };
  };
}
var packFns = __spreadProps(__spreadValues({}, packVarintFns), {
  double: getFixedPackFn(8, (dataView, byteOffset, value) => {
    dataView.setFloat64(byteOffset, value, true);
  }),
  float: getFixedPackFn(4, (dataView, byteOffset, value) => {
    dataView.setFloat32(byteOffset, value, true);
  }),
  fixed32: getFixedPackFn(4, (dataView, byteOffset, value) => {
    dataView.setUint32(byteOffset, value, true);
  }),
  fixed64: getFixedPackFn(8, (dataView, byteOffset, value) => {
    const long = Long.parse(value);
    dataView.setUint32(byteOffset, long[0], true);
    dataView.setUint32(byteOffset + 4, long[1], true);
  }),
  sfixed32: getFixedPackFn(4, (dataView, byteOffset, value) => {
    dataView.setInt32(byteOffset, value, true);
  }),
  sfixed64: getFixedPackFn(8, (dataView, byteOffset, value) => {
    const long = Long.parse(value);
    dataView.setUint32(byteOffset, long[0], true);
    dataView.setUint32(byteOffset + 4, long[1], true);
  })
});
function* unpackDouble(wireValue) {
  if (wireValue.type !== 2 /* LengthDelimited */)
    return;
  const { value } = wireValue;
  let idx = 0;
  const dataview = new DataView(value.buffer, value.byteOffset);
  while (idx < value.length) {
    const double = dataview.getFloat64(idx, true);
    idx += 4;
    yield double;
  }
}
function* unpackFloat(wireValue) {
  if (wireValue.type !== 2 /* LengthDelimited */)
    return;
  const { value } = wireValue;
  let idx = 0;
  const dataview = new DataView(value.buffer, value.byteOffset);
  while (idx < value.length) {
    const float2 = dataview.getFloat32(idx, true);
    idx += 4;
    yield float2;
  }
}
function* unpackVarint(wireValue) {
  if (wireValue.type !== 2 /* LengthDelimited */)
    return;
  const { value } = wireValue;
  let idx = 0;
  const offset = value.byteOffset;
  while (idx < value.length) {
    const decodeResult = decode(new DataView(value.buffer, offset + idx));
    idx += decodeResult[0];
    yield decodeResult[1];
  }
}
function* unpackFixed32(wireValue) {
  if (wireValue.type !== 2 /* LengthDelimited */)
    return;
  const { value } = wireValue;
  let idx = 0;
  const dataview = new DataView(value.buffer, value.byteOffset);
  while (idx < value.length) {
    const fixed32 = dataview.getUint32(idx, true);
    idx += 4;
    yield fixed32;
  }
}
function* unpackFixed64(wireValue) {
  if (wireValue.type !== 2 /* LengthDelimited */)
    return;
  const { value } = wireValue;
  let idx = 0;
  const dataview = new DataView(value.buffer, value.byteOffset);
  while (idx < value.length) {
    const lo = dataview.getUint32(idx, true);
    idx += 4;
    const hi = dataview.getUint32(idx, true);
    idx += 4;
    yield new Long(lo, hi);
  }
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/ts/messages.ts
function* gen(schema, config) {
  const {
    createImportBuffer: createImportBuffer2,
    indexBuffer,
    customTypeMapping,
    messages
  } = config;
  for (const [typePath, type] of Object.entries(schema.types)) {
    indexBuffer.reExport(getFilePath(typePath, messages, ""), "Type", typePath.split(".").pop());
    switch (type.kind) {
      case "enum":
        yield* genEnum({ typePath, type, messages });
        continue;
      case "message":
        yield* genMessage({
          schema,
          typePath,
          type,
          createImportBuffer: createImportBuffer2,
          customTypeMapping,
          messages
        });
        continue;
    }
  }
}
function getFilePath(typePath, messages, ext = ".ts") {
  return join(messages.outDir, typePath.replace(/^\./, "").replaceAll(".", "/").replaceAll(/\b([A-Z][^/]*)\//g, "($1)/") + ext);
}
var getTypeDefCodeBase = ({ typePath }, getTypeDefCodeFn) => {
  const fragments = typePath.split(".");
  const typeName = fragments.pop();
  return [
    `export declare namespace $${fragments.join(".")} {
`,
    getTypeDefCodeFn(typeName),
    `}
`,
    `export type Type = $${typePath};
`
  ].join("");
};
function* genEnum({ typePath, type, messages }) {
  const filePath = getFilePath(typePath, messages);
  const fields = Object.entries(__spreadValues({
    "0": {
      description: { leading: [], trailing: [], leadingDetached: [] },
      name: "UNSPECIFIED",
      options: {}
    }
  }, type.fields));
  yield [
    filePath,
    new StringReader([
      getTypeDefCodeBase({ typePath }, (typeName) => {
        return `  export type ${typeName} =
${fields.map(([, { name }]) => `    | "${name}"`).join("\n")};
`;
      }),
      "\n",
      `export const num2name = {
${fields.map(([fieldNumber, { name }]) => `  ${fieldNumber}: "${name}",`).join("\n")}
} as const;

`,
      `export const name2num = {
${fields.map(([fieldNumber, { name }]) => `  ${name}: ${fieldNumber},`).join("\n")}
} as const;
`
    ].join(""))
  ];
}
var reservedNames = [
  "Type",
  "Uint8Array",
  "getDefaultValue",
  "createValue",
  "encodeBinary",
  "decodeBinary",
  "encodeJson",
  "decodeJson"
];
function* genMessage({
  schema,
  typePath,
  type,
  createImportBuffer: createImportBuffer2,
  customTypeMapping,
  messages
}) {
  const filePath = getFilePath(typePath, messages);
  const importBuffer = createImportBuffer2({
    reservedNames: [...reservedNames, typePath.split(".").pop()]
  });
  const schemaFields = Object.entries(type.fields);
  const schemaOneofFields = schemaFields.filter(([, field]) => field.kind === "oneof");
  const schemaNonOneofFields = schemaFields.filter(([, field]) => field.kind !== "oneof");
  const collections = schemaNonOneofFields.filter(([, field]) => field.kind === "map" || field.kind === "repeated");
  const collectionFieldNumbers = new Set(collections.map(([fieldNumber]) => +fieldNumber));
  const everyFieldNames = new Map(schemaFields.map(([fieldNumber, { name }]) => [+fieldNumber, snakeToCamel(name)]));
  const oneofFieldTable = {};
  for (const schemaOneofField of schemaOneofFields) {
    const [, schemaField] = schemaOneofField;
    if (schemaField.kind !== "oneof")
      continue;
    const tsName = snakeToCamel(schemaField.oneof);
    const oneofField = oneofFieldTable[tsName] ?? { tsName, fields: [] };
    oneofField.fields.push(toField(schemaOneofField));
    oneofFieldTable[tsName] = oneofField;
  }
  const message = {
    schema: type,
    collectionFieldNumbers,
    everyFieldNames,
    fields: schemaNonOneofFields.map(toField),
    oneofFields: Object.values(oneofFieldTable)
  };
  const getCodeConfig = {
    typePath,
    filePath,
    importBuffer,
    message,
    messages,
    customTypeMapping
  };
  const typeDefCode = getMessageTypeDefCode(getCodeConfig);
  const getDefaultValueCode = getGetDefaultValueCode(getCodeConfig);
  const createValueCode = getCreateValueCode(getCodeConfig);
  const encodeJsonCode = getEncodeJsonCode(getCodeConfig);
  const decodeJsonCode = getDecodeJsonCode(getCodeConfig);
  const encodeBinaryCode = getEncodeBinaryCode(getCodeConfig);
  const decodeBinaryCode = getDecodeBinaryCode(getCodeConfig);
  const importCode = importBuffer.getCode();
  yield [
    filePath,
    new StringReader([
      importCode ? importCode + "\n" : "",
      typeDefCode,
      "\n" + getDefaultValueCode,
      "\n" + createValueCode,
      "\n" + encodeJsonCode,
      "\n" + decodeJsonCode,
      "\n" + encodeBinaryCode,
      "\n" + decodeBinaryCode
    ].join(""))
  ];
  function toField([fieldNumber, field]) {
    return {
      schema: field,
      fieldNumber: +fieldNumber,
      tsName: snakeToCamel(field.name),
      tsType: getFieldTypeCode(field),
      isEnum: getFieldValueIsEnum(field),
      default: getFieldDefaultCode(field)
    };
  }
  function getFieldTypeCode(field) {
    if (field.kind !== "map")
      return toTsType(field.typePath);
    const keyTypeName = toTsType(field.keyTypePath);
    const valueTypeName = toTsType(field.valueTypePath);
    return `Map<${keyTypeName}, ${valueTypeName}>`;
  }
  function getFieldValueIsEnum(field) {
    var _a;
    const typePath2 = field.kind === "map" ? field.valueTypePath : field.typePath;
    if (!typePath2)
      return false;
    return ((_a = schema.types[typePath2]) == null ? void 0 : _a.kind) === "enum";
  }
  function getFieldDefaultCode(field) {
    var _a;
    if (field.kind === "repeated")
      return "[]";
    if (field.kind === "map")
      return "new Map()";
    if (field.typePath in scalarTypeDefaultValueCodes) {
      return scalarTypeDefaultValueCodes[field.typePath];
    }
    const fieldType = schema.types[field.typePath];
    if ((fieldType == null ? void 0 : fieldType.kind) === "enum") {
      return `"${((_a = fieldType.fields[0]) == null ? void 0 : _a.name) ?? "UNSPECIFIED"}"`;
    }
  }
  function toTsType(typePath2) {
    return pbTypeToTsType({
      customTypeMapping,
      addInternalImport: importBuffer.addInternalImport,
      messages,
      here: filePath,
      typePath: typePath2
    });
  }
}
var getMessageTypeDefCode = (config) => {
  const { message } = config;
  const typeBodyCodes = [];
  if (message.fields.length)
    typeBodyCodes.push(getFieldsCode());
  if (message.oneofFields.length)
    typeBodyCodes.push(getOneofsCode());
  return getTypeDefCodeBase(config, (typeName) => {
    if (!typeBodyCodes.length)
      return `  export interface ${typeName} {}
`;
    return `  export interface ${typeName} {
${typeBodyCodes.join("")}  }
`;
  });
  function getFieldsCode() {
    return message.fields.map((field) => {
      const nullable = field.default == null || field.schema.kind === "optional";
      const opt = nullable ? "?" : "";
      const arr = field.schema.kind === "repeated" ? "[]" : "";
      const isDeprecated = field.schema.options["deprecated"] ?? false;
      if (isDeprecated) {
        return `    /** @deprecated */
    ${field.tsName}${opt}: ${field.tsType}${arr};
`;
      }
      return `    ${field.tsName}${opt}: ${field.tsType}${arr};
`;
    }).join("");
  }
  function getOneofsCode() {
    return message.oneofFields.map((oneofField) => {
      return `    ${oneofField.tsName}?: (
${oneofField.fields.map((field) => `      | { field: "${field.tsName}", value: ${field.tsType} }
`).join("")}  );
`;
    }).join("");
  }
};
var getGetDefaultValueCode = ({ typePath, message }) => {
  return [
    `export function getDefaultValue(): $${typePath} {
`,
    "  return {\n",
    message.fields.map((field) => {
      if (!field.default)
        return `    ${field.tsName}: undefined,
`;
      return `    ${field.tsName}: ${field.default},
`;
    }).join(""),
    message.oneofFields.map((field) => `    ${field.tsName}: undefined,
`).join(""),
    "  };\n",
    "}\n"
  ].join("");
};
var getCreateValueCode = ({ typePath }) => {
  return [
    `export function createValue(partialValue: Partial<$${typePath}>): $${typePath} {`,
    `  return {`,
    `    ...getDefaultValue(),`,
    `    ...partialValue,`,
    `  };`,
    `}`,
    ""
  ].join("\n");
};
var getEncodeJsonCode = ({
  typePath,
  filePath,
  importBuffer,
  message,
  messages,
  customTypeMapping
}) => {
  return [
    `export function encodeJson(value: $${typePath}): unknown {
`,
    "  const result: any = {};\n",
    message.fields.map((field) => {
      const { tsName, schema } = field;
      if (schema.kind === "oneof")
        return "";
      const tsValueToJsonValueCode = getGetTsValueToJsonValueCode({
        customTypeMapping,
        schema,
        messages
      })({ filePath, importBuffer, field });
      if (schema.kind === "repeated") {
        return [
          `  result.${tsName} = ${tsValueToJsonValueCode};
`
        ].join("");
      }
      return [
        `  if (value.${tsName} !== undefined) result.${tsName} = ${tsValueToJsonValueCode};
`
      ].join("");
    }).join(""),
    message.oneofFields.map(({ tsName, fields }) => {
      return [
        `  switch (value.${tsName}?.field) {
`,
        fields.map((field) => {
          const tsValueToJsonValueCode = getGetTsValueToJsonValueCode({
            customTypeMapping,
            schema: field.schema,
            messages
          })({
            filePath,
            importBuffer,
            field: __spreadProps(__spreadValues({}, field), { tsName: tsName + ".value" })
          });
          return [
            `    case "${field.tsName}": {
`,
            `      result.${field.tsName} = ${tsValueToJsonValueCode};
`,
            "      break;\n",
            "    }\n"
          ].join("");
        }).join(""),
        "  }\n"
      ].join("");
    }).join(""),
    "  return result;\n",
    "}\n"
  ].join("");
};
var getDecodeJsonCode = ({
  typePath,
  filePath,
  importBuffer,
  message,
  messages,
  customTypeMapping
}) => {
  return [
    `export function decodeJson(value: any): $${typePath} {
`,
    "  const result = getDefaultValue();\n",
    message.fields.map((field) => {
      const { tsName, schema } = field;
      if (schema.kind === "oneof")
        return "";
      const jsonValueToTsValueCode = getGetJsonValueToTsValueCode({
        customTypeMapping,
        schema,
        messages
      })({ filePath, importBuffer, field });
      if (schema.kind === "repeated") {
        return [
          `  result.${tsName} = ${jsonValueToTsValueCode} ?? [];
`
        ].join("");
      }
      return [
        `  if (value.${tsName} !== undefined) result.${tsName} = ${jsonValueToTsValueCode};
`
      ].join("");
    }).join(""),
    message.oneofFields.map(({ tsName, fields }) => {
      return [
        fields.map((field) => {
          const jsonValueToTsValueCode = getGetJsonValueToTsValueCode({
            customTypeMapping,
            schema: field.schema,
            messages
          })({ filePath, importBuffer, field });
          return [
            `  if (value.${field.tsName} !== undefined) result.${tsName} = {field: "${field.tsName}", value: ${jsonValueToTsValueCode}};
`
          ].join("");
        }).join("")
      ];
    }).join(""),
    `  return result;
`,
    "}\n"
  ].join("");
};
var getEncodeBinaryCode = ({
  typePath,
  filePath,
  importBuffer,
  message,
  messages,
  customTypeMapping
}) => {
  const WireMessage2 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "WireMessage");
  const serialize = importBuffer.addRuntimeImport(filePath, "wire/serialize.ts", "default", "serialize");
  return [
    `export function encodeBinary(value: $${typePath}): Uint8Array {
`,
    `  const result: ${WireMessage2} = [];
`,
    message.fields.map((field) => {
      const { fieldNumber, tsName, schema } = field;
      if (schema.kind === "oneof")
        return "";
      const tsValueToWireValueCode = getGetTsValueToWireValueCode({
        customTypeMapping,
        schema,
        messages
      })({ filePath, importBuffer, field });
      if (schema.kind === "map") {
        return [
          "  {\n",
          `    const fields = value.${tsName}.entries();
`,
          "    for (const [key, value] of fields) {\n",
          "      result.push(\n",
          `        [${fieldNumber}, ${tsValueToWireValueCode}],
`,
          "      );\n",
          "    }\n",
          "  }\n"
        ].join("");
      }
      if (schema.kind === "repeated") {
        return [
          `  for (const tsValue of value.${tsName}) {
`,
          "    result.push(\n",
          `      [${fieldNumber}, ${tsValueToWireValueCode}],
`,
          "    );\n",
          "  }\n"
        ].join("");
      }
      if (schema.kind === "optional") {
        return [
          `  if (value.${tsName} !== undefined) {
`,
          `    const tsValue = value.${tsName};
`,
          "    result.push(\n",
          `      [${fieldNumber}, ${tsValueToWireValueCode}],
`,
          "    );\n",
          "  }\n"
        ].join("");
      }
      return [
        `  if (value.${tsName} !== undefined) {
`,
        `    const tsValue = value.${tsName};
`,
        "    result.push(\n",
        `      [${fieldNumber}, ${tsValueToWireValueCode}],
`,
        "    );\n",
        "  }\n"
      ].join("");
    }).join(""),
    message.oneofFields.map(({ tsName, fields }) => {
      return [
        `  switch (value.${tsName}?.field) {
`,
        fields.map((field) => {
          const tsValueToWireValueCode = getGetTsValueToWireValueCode({
            customTypeMapping,
            schema: field.schema,
            messages
          })({ filePath, importBuffer, field });
          return [
            `    case "${field.tsName}": {
`,
            `      const tsValue = value.${tsName}.value;
`,
            "      result.push(\n",
            `        [${field.fieldNumber}, ${tsValueToWireValueCode}],
`,
            "      );\n",
            "      break;\n",
            "    }\n"
          ].join("");
        }).join(""),
        "  }\n"
      ].join("");
    }).join(""),
    `  return ${serialize}(result);
`,
    "}\n"
  ].join("");
};
var getDecodeBinaryCode = ({
  typePath,
  filePath,
  importBuffer,
  message,
  messages,
  customTypeMapping
}) => {
  const deserialize = importBuffer.addRuntimeImport(filePath, "wire/deserialize.ts", "default", "deserialize");
  return [
    message.oneofFields.length ? [
      "const fieldNames: Map<number, string> = new Map([\n",
      [...message.everyFieldNames].map(([fieldNumber, name]) => `  [${fieldNumber}, "${name}"],
`).join(""),
      "]);\n"
    ].join("") : "",
    message.oneofFields.length ? [
      "const oneofFieldNumbersMap: { [oneof: string]: Set<number> } = {\n",
      message.oneofFields.map(({ tsName, fields }) => {
        return [
          `  ${tsName}: new Set([`,
          fields.map(({ fieldNumber }) => fieldNumber).join(", "),
          "]),\n"
        ].join("");
      }).join(""),
      "};\n"
    ].join("") : "",
    message.oneofFields.length ? [
      "const oneofFieldNamesMap = {\n",
      message.oneofFields.map(({ tsName, fields }) => {
        return [
          `  ${tsName}: new Map([
`,
          fields.map(({ fieldNumber, tsName: tsName2 }) => `    [${fieldNumber}, "${tsName2}" as const],
`).join(""),
          "  ]),\n"
        ].join("");
      }).join(""),
      "};\n"
    ].join("") : "",
    `export function decodeBinary(binary: Uint8Array): $${typePath} {
`,
    "  const result = getDefaultValue();\n",
    `  const wireMessage = ${deserialize}(binary);
`,
    "  const wireFields = new Map(wireMessage);\n",
    message.oneofFields.length ? "  const wireFieldNumbers = Array.from(wireFields.keys()).reverse();\n" : "",
    message.fields.map((field) => {
      const { fieldNumber, tsName, schema } = field;
      const wireValueToTsValueCode = getGetWireValueToTsValueCode({
        customTypeMapping,
        schema,
        messages
      })({ filePath, importBuffer, field });
      if (!wireValueToTsValueCode)
        return "";
      const isCollection = message.collectionFieldNumbers.has(fieldNumber);
      if (isCollection) {
        const typePath2 = schema.typePath;
        const type = typePath2 == null ? void 0 : typePath2.slice(1);
        let wireValuesToTsValuesCode;
        if (type in unpackFns) {
          const unpackFns2 = importBuffer.addRuntimeImport(filePath, "wire/scalar.ts", "unpackFns");
          wireValuesToTsValuesCode = `Array.from(${unpackFns2}.${type}(wireValues))`;
        } else if (field.isEnum && typePath2) {
          const unpackFns2 = importBuffer.addRuntimeImport(filePath, "wire/scalar.ts", "unpackFns");
          const num2name = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "num2name");
          wireValuesToTsValuesCode = `Array.from(${unpackFns2}.int32(wireValues)).map(num => ${num2name}[num as keyof typeof ${num2name}])`;
        } else {
          wireValuesToTsValuesCode = `wireValues.map((wireValue) => ${wireValueToTsValueCode}).filter(x => x !== undefined)`;
        }
        const value = schema.kind === "map" ? "new Map(value as any)" : "value as any";
        return [
          "  collection: {\n",
          `    const wireValues = wireMessage.filter(([fieldNumber]) => fieldNumber === ${fieldNumber}).map(([, wireValue]) => wireValue);
`,
          `    const value = ${wireValuesToTsValuesCode};
`,
          "    if (!value.length) break collection;\n",
          `    result.${tsName} = ${value};
`,
          "  }\n"
        ].join("");
      } else {
        return [
          "  field: {\n",
          `    const wireValue = wireFields.get(${fieldNumber});
`,
          "    if (wireValue === undefined) break field;\n",
          `    const value = ${wireValueToTsValueCode};
`,
          "    if (value === undefined) break field;\n",
          `    result.${tsName} = value;
`,
          "  }\n"
        ].join("");
      }
    }).join(""),
    message.oneofFields.map((field) => {
      const { tsName, fields } = field;
      const Field3 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "Field");
      const wireValueToTsValueMapCode = [
        "{\n",
        fields.map((field2) => {
          const { fieldNumber, schema } = field2;
          const wireValueToTsValueCode = getGetWireValueToTsValueCode({
            customTypeMapping,
            schema,
            messages
          })({ filePath, importBuffer, field: field2 }) || "undefined";
          return `      [${fieldNumber}](wireValue: ${Field3}) { return ${wireValueToTsValueCode}; },
`;
        }).join(""),
        "    }"
      ].join("");
      return [
        "  oneof: {\n",
        `    const oneofFieldNumbers = oneofFieldNumbersMap.${tsName};
`,
        `    const oneofFieldNames = oneofFieldNamesMap.${tsName};
`,
        "    const fieldNumber = wireFieldNumbers.find(v => oneofFieldNumbers.has(v));\n",
        "    if (fieldNumber == null) break oneof;\n",
        "    const wireValue = wireFields.get(fieldNumber);\n",
        `    const wireValueToTsValueMap = ${wireValueToTsValueMapCode};
`,
        `    const value = (wireValueToTsValueMap[fieldNumber as keyof typeof wireValueToTsValueMap] as any)?.(wireValue!);
`,
        "    if (value === undefined) break oneof;\n",
        `    result.${tsName} = { field: oneofFieldNames.get(fieldNumber)!, value: value as any };
`,
        "  }\n"
      ].join("");
    }).join(""),
    "  return result;\n",
    "}\n"
  ].join("");
};
function getGetTsValueToWireValueCode({
  customTypeMapping,
  schema,
  messages
}) {
  const customTypeMappingItem = customTypeMapping[schema.typePath];
  return (customTypeMappingItem == null ? void 0 : customTypeMappingItem.getTsValueToWireValueCode) ?? ((config) => getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages })));
}
function getDefaultTsValueToWireValueCode({
  filePath,
  importBuffer,
  field,
  messages
}) {
  const { schema } = field;
  if (schema.kind === "map") {
    const { keyTypePath, valueTypePath } = schema;
    if (!keyTypePath || !valueTypePath)
      return;
    const serialize = importBuffer.addRuntimeImport(filePath, "wire/serialize.ts", "default", "serialize");
    const WireType2 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "WireType");
    const keyTypePathCode = typePathToCode("key", keyTypePath);
    const valueTypePathCode = typePathToCode("value", valueTypePath);
    const value = `${serialize}([[1, ${keyTypePathCode}], [2, ${valueTypePathCode}]])`;
    return `{ type: ${WireType2}.LengthDelimited as const, value: ${value} }`;
  }
  const { typePath } = schema;
  return typePathToCode("tsValue", typePath);
  function typePathToCode(tsValue, typePath2) {
    if (!typePath2)
      return;
    if (typePath2 in scalarTypeMapping) {
      const tsValueToWireValueFns2 = importBuffer.addRuntimeImport(filePath, "wire/scalar.ts", "tsValueToWireValueFns");
      return `${tsValueToWireValueFns2}.${typePath2.substr(1)}(${tsValue})`;
    }
    const WireType2 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "WireType");
    if (field.isEnum) {
      const Long2 = importBuffer.addRuntimeImport(filePath, "Long.ts", "default", "Long");
      const name2num = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "name2num");
      return `{ type: ${WireType2}.Varint as const, value: new ${Long2}(${name2num}[${tsValue} as keyof typeof ${name2num}]) }`;
    }
    const encodeBinary = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "encodeBinary");
    return `{ type: ${WireType2}.LengthDelimited as const, value: ${encodeBinary}(${tsValue}) }`;
  }
}
function getGetTsValueToJsonValueCode({
  customTypeMapping,
  schema,
  messages
}) {
  const customTypeMappingItem = customTypeMapping[schema.typePath];
  return (customTypeMappingItem == null ? void 0 : customTypeMappingItem.getTsValueToJsonValueCode) ?? ((config) => getDefaultTsValueToJsonValueCode(__spreadProps(__spreadValues({}, config), { messages })));
}
function getDefaultTsValueToJsonValueCode({
  filePath,
  importBuffer,
  field,
  messages
}) {
  const { schema, tsName } = field;
  if (schema.kind === "map") {
    const { keyTypePath, valueTypePath } = schema;
    if (!keyTypePath || !valueTypePath)
      return;
    const valueTypePathCode = typePathToCode("value", valueTypePath);
    return `Object.fromEntries([...value.${tsName}.entries()].map(([key, value]) => [key, ${valueTypePathCode}]))`;
  }
  if (schema.kind === "repeated") {
    const { typePath: typePath2 } = schema;
    if (!typePath2)
      return;
    const typePathCode = typePathToCode("value", typePath2);
    return `value.${tsName}.map(value => ${typePathCode})`;
  }
  const { typePath } = schema;
  return typePathToCode("value." + tsName, typePath);
  function typePathToCode(tsName2, typePath2) {
    if (!typePath2)
      return;
    if (typePath2 in scalarTypeMapping) {
      const tsValueToJsonValueFns = importBuffer.addRuntimeImport(filePath, "json/scalar.ts", "tsValueToJsonValueFns");
      return `${tsValueToJsonValueFns}.${typePath2.substr(1)}(${tsName2})`;
    }
    if (field.isEnum) {
      const tsValueToJsonValueFns = importBuffer.addRuntimeImport(filePath, "json/scalar.ts", "tsValueToJsonValueFns");
      return `${tsValueToJsonValueFns}.enum(${tsName2})`;
    }
    const encodeJson = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "encodeJson");
    return `${encodeJson}(${tsName2})`;
  }
}
function getGetJsonValueToTsValueCode({
  customTypeMapping,
  schema,
  messages
}) {
  const customTypeMappingItem = customTypeMapping[schema.typePath];
  return (customTypeMappingItem == null ? void 0 : customTypeMappingItem.getJsonValueToTsValueCode) ?? ((config) => getDefaultJsonValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages })));
}
function getDefaultJsonValueToTsValueCode({
  filePath,
  importBuffer,
  field,
  messages
}) {
  const { schema, tsName } = field;
  if (schema.kind === "map") {
    const { keyTypePath, valueTypePath } = schema;
    if (!keyTypePath || !valueTypePath)
      return;
    const valueTypePathCode = typePathToCode("value", valueTypePath);
    return `Object.fromEntries([...value.${tsName}.entries()].map(([key, value]) => [key, ${valueTypePathCode}]))`;
  }
  if (schema.kind === "repeated") {
    const { typePath: typePath2 } = schema;
    if (!typePath2)
      return;
    const typePathCode = typePathToCode("value", typePath2);
    return `value.${tsName}?.map((value: any) => ${typePathCode})`;
  }
  const { typePath } = schema;
  return typePathToCode("value." + tsName, typePath);
  function typePathToCode(jsonValue, typePath2) {
    if (!typePath2)
      return;
    const jsonValueToTsValueFns = importBuffer.addRuntimeImport(filePath, "json/scalar.ts", "jsonValueToTsValueFns");
    if (typePath2 in scalarTypeMapping) {
      return `${jsonValueToTsValueFns}.${typePath2.substr(1)}(${jsonValue})`;
    }
    if (field.isEnum) {
      if (schema.kind === "map") {
        return `${jsonValueToTsValueFns}.enum(${jsonValue})`;
      } else {
        return `${jsonValueToTsValueFns}.enum(${jsonValue}) as ${field.tsType}`;
      }
    }
    const decodeJson = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "decodeJson");
    return `${decodeJson}(${jsonValue})`;
  }
}
function getGetWireValueToTsValueCode({
  customTypeMapping,
  schema,
  messages
}) {
  const customTypeMappingItem = customTypeMapping[schema.typePath];
  return (customTypeMappingItem == null ? void 0 : customTypeMappingItem.getWireValueToTsValueCode) ?? ((config) => getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages })));
}
function getDefaultWireValueToTsValueCode({
  filePath,
  importBuffer,
  field,
  messages
}) {
  const { schema } = field;
  if (schema.kind === "map") {
    const { keyTypePath, valueTypePath } = schema;
    if (!keyTypePath || !valueTypePath)
      return;
    const deserialize = importBuffer.addRuntimeImport(filePath, "wire/deserialize.ts", "default", "deserialize");
    const WireType2 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "WireType");
    const keyTypePathCode = typePathToCode("key", keyTypePath);
    const valueTypePathCode = typePathToCode("value", valueTypePath);
    return [
      "(() => { ",
      `if (wireValue.type !== ${WireType2}.LengthDelimited) { return; } `,
      `const { 1: key, 2: value } = Object.fromEntries(${deserialize}(wireValue.value)); `,
      "if (key === undefined || value === undefined) return; ",
      `return [${keyTypePathCode}, ${valueTypePathCode}] as const;`,
      "})()"
    ].join("");
  }
  const { typePath } = schema;
  return typePathToCode("wireValue", typePath);
  function typePathToCode(wireValue, typePath2) {
    if (!typePath2)
      return;
    if (typePath2 in scalarTypeMapping) {
      const wireValueToTsValueFns2 = importBuffer.addRuntimeImport(filePath, "wire/scalar.ts", "wireValueToTsValueFns");
      return `${wireValueToTsValueFns2}.${typePath2.substr(1)}(${wireValue})`;
    }
    const WireType2 = importBuffer.addRuntimeImport(filePath, "wire/index.ts", "WireType");
    if (field.isEnum) {
      const num2name = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "num2name");
      return `${wireValue}.type === ${WireType2}.Varint ? ${num2name}[${wireValue}.value[0] as keyof typeof ${num2name}] : undefined`;
    }
    const decodeBinary = importBuffer.addInternalImport(filePath, getFilePath(typePath2, messages), "decodeBinary");
    return `${wireValue}.type === ${WireType2}.LengthDelimited ? ${decodeBinary}(${wireValue}.value) : undefined`;
  }
}
function pbTypeToTsMessageType({
  addInternalImport,
  messages,
  here,
  typePath
}) {
  var _a;
  if (!typePath)
    return "unknown";
  const from = getFilePath(typePath, messages);
  const as = (_a = typePath.match(/[^.]+$/)) == null ? void 0 : _a[0];
  return addInternalImport(here, from, "Type", as);
}
function pbTypeToTsType({
  customTypeMapping,
  addInternalImport,
  messages,
  here,
  typePath
}) {
  var _a;
  if (!typePath)
    return "unknown";
  if (typePath in scalarTypeMapping) {
    return scalarTypeMapping[typePath];
  }
  if (typePath in customTypeMapping) {
    return customTypeMapping[typePath].tsType;
  }
  const from = getFilePath(typePath, messages);
  const as = (_a = typePath.match(/[^.]+$/)) == null ? void 0 : _a[0];
  return addInternalImport(here, from, "Type", as);
}
var scalarTypeMapping = {
  ".double": "number",
  ".float": "number",
  ".int32": "number",
  ".int64": "string",
  ".uint32": "number",
  ".uint64": "string",
  ".sint32": "number",
  ".sint64": "string",
  ".fixed32": "number",
  ".fixed64": "string",
  ".sfixed32": "number",
  ".sfixed64": "string",
  ".bool": "boolean",
  ".string": "string",
  ".bytes": "Uint8Array"
};
var scalarTypeDefaultValueCodes = {
  ".double": "0",
  ".float": "0",
  ".int32": "0",
  ".int64": '"0"',
  ".uint32": "0",
  ".uint64": '"0"',
  ".sint32": "0",
  ".sint64": '"0"',
  ".fixed32": "0",
  ".fixed64": '"0"',
  ".sfixed32": "0",
  ".sfixed64": '"0"',
  ".bool": "false",
  ".string": '""',
  ".bytes": "new Uint8Array()"
};
function getWellKnownTypeMapping({
  messages
}) {
  return {
    ".google.protobuf.BoolValue": {
      tsType: "boolean",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.BytesValue": {
      tsType: "Uint8Array",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.DoubleValue": {
      tsType: "number",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.FloatValue": {
      tsType: "number",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.Int32Value": {
      tsType: "number",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.Int64Value": {
      tsType: "string",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.NullValue": {
      tsType: "null",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))}) === "NULL_VALUE" ? null : undefined`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))("NULL_VALUE")`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.StringValue": {
      tsType: "string",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.UInt32Value": {
      tsType: "number",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    },
    ".google.protobuf.UInt64Value": {
      tsType: "string",
      getWireValueToTsValueCode(config) {
        return `(${getDefaultWireValueToTsValueCode(__spreadProps(__spreadValues({}, config), { messages }))})?.value`;
      },
      getTsValueToWireValueCode(config) {
        const value = getDefaultTsValueToWireValueCode(__spreadProps(__spreadValues({}, config), { messages }));
        return `((tsValue) => (${value}))({ value: tsValue })`;
      },
      getTsValueToJsonValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      },
      getJsonValueToTsValueCode(config) {
        const { field } = config;
        return `value.${field.tsName}`;
      }
    }
  };
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/ts/services.ts
function* gen2(schema, config) {
  const {
    createImportBuffer: createImportBuffer2,
    indexBuffer,
    messages,
    services
  } = config;
  for (const [typePath, type] of Object.entries(schema.services)) {
    indexBuffer.reExport(getFilePath2(typePath, services, ""), "Service", typePath.split(".").pop());
    yield* genService({
      typePath,
      type,
      createImportBuffer: createImportBuffer2,
      messages,
      services
    });
  }
}
function getFilePath2(typePath, services, ext = ".ts") {
  return join(services.outDir, typePath.replace(/^\./, "").replaceAll(".", "/") + ext);
}
var reservedNames2 = ["Service", "Uint8Array"];
function* genService({
  typePath,
  type,
  createImportBuffer: createImportBuffer2,
  messages,
  services
}) {
  const filePath = getFilePath2(typePath, services);
  const importBuffer = createImportBuffer2({ reservedNames: reservedNames2 });
  const serviceTypeDefCode = getServiceTypeDefCode({
    filePath,
    importBuffer,
    service: type,
    messages
  });
  const methodDescriptorsCode = getMethodDescriptorsCode({
    filePath,
    typePath,
    importBuffer,
    service: type,
    messages
  });
  const createServiceClientCode = getCreateServiceClientCode({
    filePath,
    importBuffer,
    service: type
  });
  yield [
    filePath,
    new StringReader([
      importBuffer.getCode() + "\n",
      serviceTypeDefCode + "\n",
      methodDescriptorsCode + "\n",
      createServiceClientCode
    ].join(""))
  ];
}
function getServiceTypeDefCode({
  filePath,
  importBuffer,
  messages,
  service
}) {
  function getTsType(typePath) {
    return pbTypeToTsMessageType({
      addInternalImport: importBuffer.addInternalImport,
      messages,
      here: filePath,
      typePath
    });
  }
  function getTsRpcType(rpcType, isRes) {
    const typeName = getTsType(rpcType.typePath);
    if (rpcType.stream)
      return `AsyncGenerator<${typeName}>`;
    return isRes ? `Promise<${typeName}>` : typeName;
  }
  return `export interface Service<TReqArgs extends any[] = [], TResArgs extends any[] = []> {
${getRpcsCode()}}
`;
  function getRpcsCode() {
    const isServiceEmpty = Object.keys(service.rpcs).length < 1;
    if (isServiceEmpty)
      return "";
    const RpcReturnType = importBuffer.addRuntimeImport(filePath, "rpc.ts", "RpcReturnType");
    return Object.entries(service.rpcs).map(([rpcName, rpc]) => {
      const reqType = getTsRpcType(rpc.reqType);
      const resType = getTsRpcType(rpc.resType, true);
      return `  ${pascalToCamel(rpcName)}(request: ${reqType}, ...args: TReqArgs): ${RpcReturnType}<${resType}, TResArgs>;
`;
    }).join("");
  }
}
function getMethodDescriptorsCode({
  filePath,
  typePath,
  importBuffer,
  service,
  messages
}) {
  function getTsType(typePath2) {
    return pbTypeToTsMessageType({
      addInternalImport: importBuffer.addInternalImport,
      messages,
      here: filePath,
      typePath: typePath2
    });
  }
  return [
    "export type MethodDescriptors = typeof methodDescriptors;\n",
    "export const methodDescriptors = {\n",
    Object.entries(service.rpcs).map(([rpcName, rpc]) => {
      const camelRpcName = pascalToCamel(rpcName);
      const encodeRequestBinary = importBuffer.addInternalImport(filePath, getFilePath(rpc.reqType.typePath, messages), "encodeBinary");
      const decodeRequestBinary = importBuffer.addInternalImport(filePath, getFilePath(rpc.reqType.typePath, messages), "decodeBinary");
      const encodeRequestJson = importBuffer.addInternalImport(filePath, getFilePath(rpc.reqType.typePath, messages), "encodeJson");
      const encodeResponseBinary = importBuffer.addInternalImport(filePath, getFilePath(rpc.resType.typePath, messages), "encodeBinary");
      const decodeResponseBinary = importBuffer.addInternalImport(filePath, getFilePath(rpc.resType.typePath, messages), "decodeBinary");
      const encodeResponseJson = importBuffer.addInternalImport(filePath, getFilePath(rpc.resType.typePath, messages), "encodeJson");
      return [
        `  ${camelRpcName}: {
`,
        `    methodName: "${rpcName}",
`,
        `    service: { serviceName: "${typePath.substr(1)}" },
`,
        `    requestStream: ${rpc.reqType.stream ? "true" : "false"},
`,
        `    responseStream: ${rpc.resType.stream ? "true" : "false"},
`,
        `    requestType: {
`,
        `      serializeBinary: ${encodeRequestBinary},
`,
        `      deserializeBinary: ${decodeRequestBinary},
`,
        `      serializeJson: (value: ${getTsType(rpc.reqType.typePath)}) => JSON.stringify(${encodeRequestJson}(value)),
`,
        `    },
`,
        `    responseType: {
`,
        `      serializeBinary: ${encodeResponseBinary},
`,
        `      deserializeBinary: ${decodeResponseBinary},
`,
        `      serializeJson: (value: ${getTsType(rpc.resType.typePath)}) => JSON.stringify(${encodeResponseJson}(value)),
`,
        `    },
`,
        "  },\n"
      ].join("");
    }).join(""),
    "} as const;\n"
  ].join("");
}
function getCreateServiceClientCode({
  filePath,
  importBuffer,
  service
}) {
  const RpcClientImpl = importBuffer.addRuntimeImport(filePath, "rpc.ts", "RpcClientImpl");
  return `export class RpcError<TTrailer = any> extends Error {
  constructor(public trailer: TTrailer) { super(); }
}
export interface CreateServiceClientConfig {
  responseOnly?: boolean;
  devtools?: true | { tags: string[] };
}
export function createServiceClient<TMetadata, THeader, TTrailer>(
  rpcClientImpl: ${RpcClientImpl}<TMetadata, THeader, TTrailer>,
  config?: undefined
): Service<[] | [TMetadata], []>;
export function createServiceClient<TMetadata, THeader, TTrailer>(
  rpcClientImpl: ${RpcClientImpl}<TMetadata, THeader, TTrailer>,
  config: CreateServiceClientConfig & { responseOnly: false }
): Service<[] | [TMetadata], [THeader, Promise<TTrailer>]>;
export function createServiceClient<TMetadata, THeader, TTrailer>(
  rpcClientImpl: ${RpcClientImpl}<TMetadata, THeader, TTrailer>,
  config: CreateServiceClientConfig & { responseOnly?: true }
): Service<[] | [TMetadata], []>;
export function createServiceClient<TMetadata, THeader, TTrailer>(
  rpcClientImpl: ${RpcClientImpl}<TMetadata, THeader, TTrailer>,
  config?: CreateServiceClientConfig
): Service<[] | [TMetadata], [] | [THeader, Promise<TTrailer>]> ${getCreateServiceClientBody()}
`;
  function getCreateServiceClientBody() {
    const isServiceEmpty = Object.keys(service.rpcs).length < 1;
    if (isServiceEmpty) {
      return `{
  return {};
}`;
    }
    const MethodDescriptor = importBuffer.addRuntimeImport(filePath, "rpc.ts", "MethodDescriptor");
    const fromSingle = importBuffer.addRuntimeImport(filePath, "async/async-generator.ts", "fromSingle");
    const first = importBuffer.addRuntimeImport(filePath, "async/async-generator.ts", "first");
    const wrapRpcClientImpl = importBuffer.addRuntimeImport(filePath, "client-devtools.ts", "wrapRpcClientImpl");
    const getDevtoolsConfig = importBuffer.addRuntimeImport(filePath, "client-devtools.ts", "getDevtoolsConfig");
    return `{
  let _rpcClientImpl = rpcClientImpl;
  const responseOnly = config?.responseOnly ?? true;
  const devtools = config?.devtools ?? false;
  if (devtools) {
    const tags = devtools === true ? [] : devtools.tags;
    const devtoolsConfig = ${getDevtoolsConfig}();
    _rpcClientImpl = ${wrapRpcClientImpl}({ rpcClientImpl, devtoolsConfig, tags });
  }
  return Object.fromEntries(Object.entries(methodDescriptors).map(
    ([camelRpcName, methodDescriptor]) => {
      const { requestStream, responseStream } = methodDescriptor;
      const rpcMethodImpl = _rpcClientImpl(methodDescriptor as ${MethodDescriptor}<any, any>);
      const rpcMethodHandler = async (request: any, metadata?: any) => {
        const reqAsyncGenerator = requestStream ? request : ${fromSingle}(request);
        const rpcMethodResult = rpcMethodImpl(reqAsyncGenerator, metadata);
        const resAsyncGenerator = rpcMethodResult[0];
        const headerPromise = rpcMethodResult[1];
        const trailerPromise = rpcMethodResult[2];
        const [header, response] = await Promise.all([
          getHeaderBeforeTrailer(headerPromise, trailerPromise),
          responseStream ? resAsyncGenerator : ${first}(resAsyncGenerator),
        ]);
        return responseOnly ? response : [response, header, trailerPromise];
      };
      return [camelRpcName, rpcMethodHandler];
    }
  )) as unknown as Service;
}
function getHeaderBeforeTrailer<THeader, TTrailer>(
  headerPromise: Promise<THeader>,
  trailerPromise: Promise<TTrailer>
): Promise<THeader> {
  return Promise.race([
    headerPromise,
    trailerPromise.then(trailer => { throw new RpcError(trailer); }),
  ]);
}`;
  }
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/ts/import-buffer.ts
function createImportBuffer(config) {
  const froms = {};
  const conflictTable = {};
  const reservedNames3 = config.reservedNames ?? [];
  const runtime = config.runtime ?? { packageName: "@pbkit/runtime" };
  for (const reservedName of reservedNames3) {
    conflictTable[reservedName] = { "": 0 };
  }
  const importBuffer = {
    addInternalImport(here, from, item, as) {
      const _from = relative(dirname(here), from);
      const __from = _from[0] !== "." ? `./${_from}` : _from;
      return importBuffer.addImport(__from, item, as);
    },
    addImport(from, item, as) {
      const _as = as ?? item;
      const fromAndItem = `${from},${item}`;
      const items = froms[from] = froms[from] ?? {};
      const conflictCountTable = conflictTable[_as] = conflictTable[_as] ?? {};
      let conflictCount;
      if (fromAndItem in conflictCountTable) {
        conflictCount = conflictCountTable[fromAndItem];
      } else {
        conflictCount = Object.keys(conflictCountTable).length;
        conflictCountTable[fromAndItem] = conflictCount;
      }
      const __as = conflictCount ? `${_as}_${conflictCount}` : _as;
      items[__as] = item;
      return __as;
    },
    addRuntimeImport(here, from, item, as) {
      if (runtime.packageName == null) {
        const _from = join(runtime.outDir, from);
        return importBuffer.addInternalImport(here, _from, item, as);
      } else {
        const _from = join(runtime.packageName, from);
        return importBuffer.addImport(_from, item, as);
      }
    },
    getCode() {
      return Object.entries(froms).map(([from, items]) => {
        const itemsCode = Object.entries(items).map(([as, item]) => {
          if (as === item)
            return `  ${item},
`;
          return `  ${item} as ${as},
`;
        }).join("");
        return `import {
${itemsCode}} from "${from}";
`;
      }).join("");
    }
  };
  return importBuffer;
}

// deno:file:///home/runner/work/pbkit/pbkit/misc/directory.ts
var empty = Object.freeze({
  type: "folder",
  children: Object.freeze({})
});
function file(value) {
  return { type: "file", value };
}
function textToPath(text, sep = "/") {
  return text.split(sep).filter(Boolean);
}
function* walkFolders(node, path = []) {
  if (node.type === "file")
    return;
  yield [path, node];
  for (const [name, child] of Object.entries(node.children)) {
    if (child.type === "folder")
      yield* walkFolders(child, [...path, name]);
  }
}
function get(node, path) {
  if (path.length < 1)
    return node;
  if (node.type === "file")
    return;
  const child = node.children[path[0]];
  if (!child)
    return;
  if (path.length === 1)
    return child;
  return get(child, path.slice(1));
}
function set2(node, path, value) {
  var _a;
  if (path.length < 1)
    return __spreadProps(__spreadValues({}, node), { value });
  const key = path[0];
  const folder = node;
  const child = (_a = folder == null ? void 0 : folder.children) == null ? void 0 : _a[key];
  return __spreadProps(__spreadValues({}, node), {
    type: "folder",
    children: __spreadProps(__spreadValues({}, folder.children), {
      [key]: !child && path.length === 1 ? file(value) : set2(child ?? empty, path.slice(1), value)
    })
  });
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/ts/index-buffer.ts
function createIndexBuffer(config) {
  let root = empty;
  const indexFilename = (config == null ? void 0 : config.indexFilename) || "index";
  const folderEntryToImportStmt = ([name]) => {
    return `import * as ${name} from "./${name}/${indexFilename}.ts";
`;
  };
  return {
    reExport(from, item, as) {
      var _a;
      const path = textToPath(from);
      const items = (_a = get(root, path)) == null ? void 0 : _a.value;
      root = set2(root, path, __spreadProps(__spreadValues({}, items), { [item]: as }));
    },
    *[Symbol.iterator]() {
      for (const [path, folder] of walkFolders(root)) {
        const entries = Object.entries(folder.children);
        const folders = entries.filter(([name, node]) => !name.startsWith("(") && !node.value);
        const files = entries.filter(([, node]) => node.value);
        const codes = [
          ...folders.map(folderEntryToImportStmt),
          folders.length ? `export type {
${folders.map(([name]) => `  ${name},
`).join("")}};
` : "",
          ...files.flatMap(([name, { value }]) => Object.entries(value).map(([item, as]) => `export type { ${item} as ${as} } from "./${name}.ts";
`))
        ];
        yield [
          [...path, `${indexFilename}.ts`].join("/"),
          new StringReader(codes.join(""))
        ];
      }
    }
  };
}

// deno:file:///home/runner/work/pbkit/pbkit/codegen/ts/index.ts
function gen3(schema, config = {}) {
  const { messages, services } = config;
  const units = [{ schema, messages, services }];
  return replaceExts(filterDuplicates(genAll(__spreadProps(__spreadValues({}, config), { units }))), config.extInImport);
}
function bundle(config) {
  return replaceExts(filterDuplicates(genAll(config)), config.extInImport);
}
async function* genAll(config) {
  const { units, customTypeMapping, runtime, indexFilename } = config;
  const _runtime = runtime ?? { packageName: "@pbkit/runtime" };
  if (_runtime.packageName == null && !_runtime.outDir.startsWith("../")) {
    for await (const [filePath, data] of _runtime.iterRuntimeFiles()) {
      yield [join(_runtime.outDir, filePath), data];
    }
  }
  const createImportBuffer2 = (config2) => createImportBuffer(__spreadProps(__spreadValues({}, config2), { runtime: _runtime }));
  const indexBuffer = createIndexBuffer({ indexFilename });
  for await (const unit of units) {
    yield* genBuildUnit(unit, createImportBuffer2, indexBuffer, customTypeMapping);
  }
  yield* indexBuffer;
}
async function* genBuildUnit(unit, createImportBuffer2, indexBuffer, _customTypeMapping) {
  const { schema } = unit;
  const messages = unit.messages ?? { outDir: "messages" };
  const services = unit.services ?? { outDir: "services" };
  const customTypeMapping = __spreadValues(__spreadValues({}, getWellKnownTypeMapping({ messages })), _customTypeMapping);
  yield* gen(schema, {
    createImportBuffer: createImportBuffer2,
    indexBuffer,
    customTypeMapping,
    messages
  });
  yield* gen2(schema, {
    createImportBuffer: createImportBuffer2,
    indexBuffer,
    messages,
    services
  });
}
async function* filterDuplicates(codes) {
  const filter = /* @__PURE__ */ new Set();
  for await (const [filePath, data] of codes) {
    if (filter.has(filePath))
      continue;
    filter.add(filePath);
    yield [filePath, data];
  }
}
async function* replaceExts(codes, extInImport = ".ts") {
  const ext = extInImport.trim();
  const replaceExt = replaceTsFileExtensionInImportStatementFromReader;
  for await (const [filePath, data] of codes) {
    yield [filePath, ext !== ".ts" ? await replaceExt(data, ext) : data];
  }
}
async function yamlToBundleConfig(yaml, getBuildConfig, iterRuntimeFiles) {
  return {
    indexFilename: yaml["index-filename"],
    extInImport: yaml["ext-in-import"],
    runtime: yaml["runtime-package"] ? { packageName: yaml["runtime-package"].trim() } : { iterRuntimeFiles, outDir: (yaml["runtime-dir"] ?? "runtime").trim() },
    units: await Promise.all((yaml["units"] ?? []).map(async (unit) => {
      const schema = await build(await getBuildConfig(unit["proto-paths"] ?? [], unit["entry-paths"] ?? [], unit["proto-files"] ?? []));
      return {
        schema,
        messages: { outDir: (unit["messages-dir"] ?? "messages").trim() },
        services: { outDir: (unit["services-dir"] ?? "services").trim() }
      };
    }))
  };
}
async function yamlTextToBundleConfig(configYamlText, getBuildConfig, iterRuntimeFiles) {
  const yaml = parse(configYamlText);
  const outDir = yaml["out-dir"] ?? "out";
  return [
    outDir,
    await yamlToBundleConfig(yaml, getBuildConfig, iterRuntimeFiles)
  ];
}
export {
  bundle,
  gen3 as default,
  yamlTextToBundleConfig,
  yamlToBundleConfig
};
