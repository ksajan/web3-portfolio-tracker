"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeDocs = exports.getTypeInformation = exports.isTypeSpecifier = void 0;
const index_1 = require("../visitor/index");
const builder_1 = require("./builder");
const stringify_ast_frag_1 = require("./stringify-ast-frag");
const ast_util_1 = require("./ast-util");
const eval_ast_constant_1 = require("./eval-ast-constant");
function gotoDefinition(schema, filePath, colRow) {
    if (!schema.files[filePath])
        return;
    const file = schema.files[filePath];
    const { parseResult } = file;
    if (!parseResult)
        return;
    const offset = parseResult.parser.colRowToOffset(colRow);
    const context = { schema, filePath, offset, file };
    return handleImportStatements(context) || handleTypeReferences(context);
}
exports.default = gotoDefinition;
function handleImportStatements({ file, offset }) {
    const importStatements = (0, ast_util_1.filterNodesByType)(file.parseResult.ast.statements, "import");
    for (const importStatement of importStatements) {
        const { strLit } = importStatement;
        if (offset < strLit.start)
            continue;
        if (offset > strLit.end)
            continue;
        const importPath = (0, eval_ast_constant_1.evalStrLit)(strLit);
        const i = file.imports.find((i) => i.importPath === importPath);
        if (!(i === null || i === void 0 ? void 0 : i.filePath))
            return;
        return {
            filePath: i.filePath,
            start: { col: 0, row: 0 },
            end: { col: 0, row: 0 },
        };
    }
}
function handleTypeReferences({ schema, filePath, offset, file }) {
    var _a, _b;
    const typeReference = getTypeReference(file.parseResult, offset);
    if (!typeReference)
        return;
    const typePath = (0, builder_1.getResolveTypePathFn)(schema, filePath)((0, stringify_ast_frag_1.stringifyType)(typeReference.node), typeReference.scope);
    if (!typePath)
        return;
    const type = schema.types[typePath];
    if (!type)
        return;
    const parser = (_b = (_a = schema.files[type.filePath]) === null || _a === void 0 ? void 0 : _a.parseResult) === null || _b === void 0 ? void 0 : _b.parser;
    if (!parser)
        return;
    const typeDefinition = getTypeDefinition(schema, typePath);
    if (!typeDefinition)
        return;
    const { start, end } = getNameToken(typeDefinition);
    return {
        filePath: type.filePath,
        start: parser.offsetToColRow(start),
        end: parser.offsetToColRow(end),
    };
}
function isTypeSpecifier(parseResult, colRow) {
    const offset = parseResult.parser.colRowToOffset(colRow);
    const typeRef = getTypeReference(parseResult, offset);
    return Boolean(typeRef);
}
exports.isTypeSpecifier = isTypeSpecifier;
function getTypeInformation(schema, filePath, colRow) {
    if (!schema.files[filePath])
        return;
    const { parseResult } = schema.files[filePath];
    if (!parseResult)
        return;
    const offset = parseResult.parser.colRowToOffset(colRow);
    const typeReference = getTypeReference(parseResult, offset);
    if (!typeReference)
        return;
    const typePath = (0, builder_1.getResolveTypePathFn)(schema, filePath)((0, stringify_ast_frag_1.stringifyType)(typeReference.node), typeReference.scope);
    if (!typePath)
        return;
    const type = schema.types[typePath];
    if (!type)
        return;
    return getTypeDocs(type, typePath);
}
exports.getTypeInformation = getTypeInformation;
function getTypeDocs(type, typePath) {
    const fields = getFields(type);
    return [
        "```proto",
        `${type.kind} ${typePath.split(".").pop()} {`,
        ...fields.map((field) => "  " + field),
        "}",
        "```",
    ].join("\n");
    function getFields(type) {
        switch (type.kind) {
            case "message":
                return Object.entries(type.fields).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([fieldNumber, value]) => {
                    if (value.kind === "map") {
                        return `map<${value.keyType}, ${value.valueType}> ${fieldNumber} = ${fieldNumber};`;
                    }
                    return `${value.typePath ? value.typePath.slice(1) : ""} ${value.name} = ${fieldNumber};`;
                });
            case "enum":
                return Object.entries(type.fields).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([fieldNumber, value]) => {
                    return `${value.name} = ${fieldNumber};`;
                });
        }
    }
}
exports.getTypeDocs = getTypeDocs;
function getTypeReference(parseResult, offset) {
    let result;
    const stack = [];
    const visitor = {
        ...index_1.visitor,
        visitSyntax() { },
        visitImport() { },
        visitOption() { },
        visitEmpty() { },
        visitPackage(_visitor, node) {
            stack.push((0, stringify_ast_frag_1.stringifyFullIdent)(node.fullIdent));
        },
        visitTopLevelDef(visitor, node) {
            if (offset < node.start)
                return;
            if (offset >= node.end)
                return;
            return index_1.visitor.visitTopLevelDef(visitor, node);
        },
        visitMessage(visitor, node) {
            stack.push(node.messageName.text);
            index_1.visitor.visitMessage(visitor, node);
            stack.pop();
        },
        visitType(_visitor, node) {
            if (offset < node.start)
                return;
            if (offset > node.end)
                return;
            result = { node, scope: `.${stack.join(".")}` };
        },
    };
    visitor.visitProto(visitor, parseResult.ast);
    return result;
}
function getTypeDefinition(schema, typePath) {
    var _a;
    let result;
    const stack = [];
    const type = schema.types[typePath];
    if (!type)
        return;
    const parseResult = (_a = schema.files[type.filePath]) === null || _a === void 0 ? void 0 : _a.parseResult;
    if (!parseResult)
        return;
    const visitor = {
        ...index_1.visitor,
        visitSyntax() { },
        visitImport() { },
        visitPackage(_visitor, node) {
            stack.push((0, stringify_ast_frag_1.stringifyFullIdent)(node.fullIdent));
        },
        visitOption() { },
        visitEmpty() { },
        visitMessage(visitor, node) {
            stack.push(node.messageName.text);
            setResult(node);
            index_1.visitor.visitMessage(visitor, node);
            stack.pop();
        },
        visitEnum(visitor, node) {
            stack.push(node.enumName.text);
            setResult(node);
            index_1.visitor.visitEnum(visitor, node);
            stack.pop();
        },
    };
    visitor.visitProto(visitor, parseResult.ast);
    return result;
    function setResult(node) {
        if (`.${stack.join(".")}` === typePath)
            result = node;
    }
}
function getNameToken(node) {
    switch (node.type) {
        case "message":
            return node.messageName;
        case "enum":
            return node.enumName;
    }
}
