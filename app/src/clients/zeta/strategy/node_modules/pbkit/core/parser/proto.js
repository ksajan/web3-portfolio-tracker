"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConstant = exports.parse = void 0;
const recursive_descent_parser_1 = require("./recursive-descent-parser");
const createProtoParser = recursive_descent_parser_1.createRecursiveDescentParser;
function parse(text) {
    const comments = [];
    const parser = createProtoParser(text);
    parser.on("comment", (comment) => comments.push(comment));
    const statements = acceptStatements(parser, [
        acceptSyntax,
        acceptImport,
        acceptPackage,
        acceptOption,
        acceptMessage,
        acceptEnum,
        acceptExtend,
        acceptService,
        acceptEmpty,
    ]);
    const ast = { statements };
    return { ast, parser, comments };
}
exports.parse = parse;
function parseConstant(text) {
    const parser = createProtoParser(text);
    const constant = expectConstant(parser);
    return { ast: constant, parser, comments: [] };
}
exports.parseConstant = parseConstant;
function mergeSpans(spans) {
    let start = Infinity;
    let end = -Infinity;
    for (let i = 0; i < spans.length; ++i) {
        if (spans[i] == null)
            continue;
        const span = Array.isArray(spans[i])
            ? mergeSpans(spans[i])
            : spans[i];
        start = Math.min(start, span.start);
        end = Math.max(end, span.end);
    }
    return { start, end };
}
function acceptPatternAndThen(pattern, then) {
    return function accept(parser) {
        const token = parser.accept(pattern);
        if (!token)
            return;
        return then(token);
    };
}
function choice(acceptFns) {
    return function accept(parser) {
        for (const acceptFn of acceptFns) {
            const node = acceptFn(parser);
            if (node)
                return node;
        }
    };
}
function many(parser, acceptFn) {
    const nodes = [];
    let node;
    while (node = acceptFn(parser))
        nodes.push(node);
    return nodes;
}
function acceptComplexSequence(parser, expectFnSeq, escapePattern) {
    const result = {};
    let partial = false;
    let hasNewline = false;
    let recoveryPoint;
    for (const [key, expectFn] of expectFnSeq) {
        const loc = parser.loc;
        hasNewline = skipWsAndComments2(parser);
        if (hasNewline && !recoveryPoint) {
            recoveryPoint = { loc: parser.loc, result: { ...result } };
        }
        try {
            result[key] = expectFn(parser);
        }
        catch {
            parser.loc = loc;
            partial = true;
            if (escapePattern && parser.try(escapePattern))
                break;
        }
    }
    if (partial && recoveryPoint) {
        parser.loc = recoveryPoint.loc;
        return { partial, result: recoveryPoint.result };
    }
    return { partial, result };
}
function acceptStatements(parser, acceptStatementFns) {
    const statements = [];
    statements: while (true) {
        const { commentGroups, trailingNewline } = skipWsAndSweepComments(parser);
        let leadingComments;
        let leadingDetachedComments;
        if (trailingNewline) {
            leadingComments = [];
            leadingDetachedComments = commentGroups;
        }
        else {
            if (commentGroups.length < 1) {
                leadingComments = [];
                leadingDetachedComments = [];
            }
            else {
                leadingComments = [commentGroups.pop()];
                leadingDetachedComments = commentGroups;
            }
        }
        for (const acceptStatementFn of acceptStatementFns) {
            const statement = acceptStatementFn(parser, leadingComments, leadingDetachedComments);
            if (statement) {
                statements.push(statement);
                continue statements;
            }
        }
        break;
    }
    return statements;
}
const whitespacePattern = /^\s+/;
const whitespaceWithoutNewlinePattern = /^[ \f\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
const newlinePattern = /^\r?\n/;
const multilineCommentPattern = /^\/\*(?:.|\r?\n)*?\*\//;
const singlelineCommentPattern = /^\/\/.*(?:\r?\n|$)/;
const intLitPattern = /^0(?:x[0-9a-f]+|[0-7]*)|^[1-9]\d*/i;
const floatLitPattern = /^\d+\.\d*(?:e[-+]?\d+)?|^\d+e[-+]?\d+|^\.\d+(?:e[-+]?\d+)?|^inf|^nan/i;
const boolLitPattern = /^true|^false/;
const strLitPattern = /^'(?:\\x[0-9a-f]{2}|\\[0-7]{3}|\\[0-7]|\\[abfnrtv\\\?'"]|[^'\0\n\\])*'|^"(?:\\x[0-9a-f]{2}|\\[0-7]{3}|\\[0-7]|\\[abfnrtv\\\?'"]|[^"\0\n\\])*"/i;
const identPattern = /^[a-z_][a-z0-9_]*/i;
const messageBodyStatementKeywordPattern = /^(?:enum|message|extend|extensions|group|option|oneof|map|reserved)\b/;
const acceptDot = acceptPatternAndThen(".", (dot) => ({ type: "dot", ...dot }));
const acceptComma = acceptPatternAndThen(",", (comma) => ({ type: "comma", ...comma }));
const acceptSemi = acceptPatternAndThen(";", (semi) => ({ type: "semi", ...semi }));
function expectSemi(parser) {
    const semi = acceptSemi(parser);
    if (semi)
        return semi;
    throw new recursive_descent_parser_1.SyntaxError(parser, [";"]);
}
const acceptIdent = acceptPatternAndThen(identPattern, (ident) => ({ type: "ident", ...ident }));
function acceptSpecialToken(parser, type, pattern = identPattern) {
    const token = parser.accept(pattern);
    if (!token)
        return;
    return { type, ...token };
}
function acceptKeyword(parser, pattern = identPattern) {
    return acceptSpecialToken(parser, "keyword", pattern);
}
function acceptCommentGroup(parser) {
    const loc = parser.loc;
    const comments = [];
    while (true) {
        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
        if (whitespace)
            continue;
        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
        if (multilineComment) {
            parser.emit("comment", multilineComment);
            comments.push(multilineComment);
            continue;
        }
        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
        if (singlelineComment) {
            parser.emit("comment", singlelineComment);
            comments.push(singlelineComment);
            continue;
        }
        break;
    }
    if (comments.length < 1) {
        parser.loc = loc;
        return;
    }
    return {
        ...mergeSpans(comments),
        type: "comment-group",
        comments,
    };
}
function acceptTrailingComments(parser) {
    const loc = parser.loc;
    const comments = [];
    while (true) {
        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
        if (whitespace)
            continue;
        const newline = parser.accept(newlinePattern);
        if (newline)
            break;
        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
        if (multilineComment) {
            comments.push(multilineComment);
            continue;
        }
        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
        if (singlelineComment) {
            comments.push(singlelineComment);
            break;
        }
        break;
    }
    if (comments.length < 1) {
        parser.loc = loc;
        return [];
    }
    return [{
            ...mergeSpans(comments),
            type: "comment-group",
            comments,
        }];
}
function skipWsAndSweepComments(parser) {
    const commentGroups = [];
    let trailingNewline = false;
    parser.accept(whitespacePattern);
    while (true) {
        const commentGroup = acceptCommentGroup(parser);
        if (commentGroup) {
            commentGroups.push(commentGroup);
            trailingNewline = false;
            continue;
        }
        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
        if (whitespace)
            continue;
        const newline = parser.accept(newlinePattern);
        if (newline) {
            trailingNewline = true;
            continue;
        }
        break;
    }
    return {
        commentGroups,
        trailingNewline,
    };
}
function skipWsAndComments(parser) {
    while (true) {
        const whitespace = parser.accept(whitespacePattern);
        if (whitespace)
            continue;
        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
        if (multilineComment) {
            parser.emit("comment", multilineComment);
            continue;
        }
        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
        if (singlelineComment) {
            parser.emit("comment", singlelineComment);
            continue;
        }
        break;
    }
    return;
}
function skipWsAndComments2(parser) {
    let hasNewline = false;
    while (true) {
        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);
        if (whitespace)
            continue;
        const newline = parser.accept(newlinePattern);
        if (newline) {
            hasNewline = true;
            continue;
        }
        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);
        if (multilineComment) {
            parser.emit("comment", multilineComment);
            continue;
        }
        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);
        if (singlelineComment) {
            parser.emit("comment", singlelineComment);
            hasNewline = true;
            continue;
        }
        break;
    }
    return hasNewline;
}
function acceptFullIdent(parser) {
    const identOrDots = many(parser, choice([
        acceptDot,
        acceptIdent,
    ]));
    if (identOrDots.length < 1)
        return;
    return {
        ...mergeSpans(identOrDots),
        type: "full-ident",
        identOrDots,
    };
}
function expectFullIdent(parser) {
    const fullIdent = acceptFullIdent(parser);
    if (fullIdent)
        return fullIdent;
    throw new recursive_descent_parser_1.SyntaxError(parser, [".", identPattern]);
}
function acceptType(parser) {
    const identOrDots = many(parser, choice([
        acceptDot,
        acceptIdent,
    ]));
    if (identOrDots.length < 1)
        return;
    return {
        ...mergeSpans(identOrDots),
        type: "type",
        identOrDots,
    };
}
function expectType(parser) {
    const type = acceptType(parser);
    if (type)
        return type;
    throw new recursive_descent_parser_1.SyntaxError(parser, [".", identPattern]);
}
function acceptIntLit(parser) {
    const intLit = parser.accept(intLitPattern);
    if (!intLit)
        return;
    return { type: "int-lit", ...intLit };
}
function expectIntLit(parser) {
    const intLit = acceptIntLit(parser);
    if (intLit)
        return intLit;
    throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern]);
}
function acceptSignedIntLit(parser) {
    var _a;
    const loc = parser.loc;
    const sign = (_a = parser.accept("-")) !== null && _a !== void 0 ? _a : parser.accept("+");
    const intLit = acceptIntLit(parser);
    if (!intLit) {
        parser.loc = loc;
        return;
    }
    return {
        ...mergeSpans([sign, intLit]),
        type: "signed-int-lit",
        sign,
        value: intLit,
    };
}
function expectSignedIntLit(parser) {
    const signedIntLit = acceptSignedIntLit(parser);
    if (signedIntLit)
        return signedIntLit;
    throw new recursive_descent_parser_1.SyntaxError(parser, ["-", intLitPattern]);
}
function acceptFloatLit(parser) {
    const floatLit = parser.accept(floatLitPattern);
    if (!floatLit)
        return;
    return { type: "float-lit", ...floatLit };
}
function acceptSignedFloatLit(parser) {
    var _a;
    const loc = parser.loc;
    const sign = (_a = parser.accept("-")) !== null && _a !== void 0 ? _a : parser.accept("+");
    const floatLit = acceptFloatLit(parser);
    if (!floatLit) {
        parser.loc = loc;
        return;
    }
    return {
        ...mergeSpans([sign, floatLit]),
        type: "signed-float-lit",
        sign,
        value: floatLit,
    };
}
function acceptBoolLit(parser) {
    const boolLit = parser.accept(boolLitPattern);
    if (!boolLit)
        return;
    return { type: "bool-lit", ...boolLit };
}
function acceptStrLit(parser) {
    const strLit = parser.accept(strLitPattern);
    if (!strLit)
        return;
    const tokens = [strLit];
    while (true) {
        skipWsAndComments(parser);
        const strLit = parser.accept(strLitPattern);
        if (!strLit)
            break;
        tokens.push(strLit);
    }
    return { ...mergeSpans(tokens), type: "str-lit", tokens };
}
function expectStrLit(parser) {
    const strLit = acceptStrLit(parser);
    if (strLit)
        return strLit;
    throw new recursive_descent_parser_1.SyntaxError(parser, [strLitPattern]);
}
// https://github.com/protocolbuffers/protobuf/blob/c2148566c7/src/google/protobuf/compiler/parser.cc#L1429-L1452
function acceptAggregate(parser) {
    const parenthesisOpen = parser.accept("{");
    if (!parenthesisOpen)
        return;
    let character = parenthesisOpen;
    let depth = 1;
    while (character = parser.expect(/^(?:\s|\S)/)) {
        switch (character.text) {
            case "{":
                ++depth;
                break;
            case "}":
                --depth;
                break;
        }
        if (depth === 0) {
            break;
        }
    }
    return {
        ...mergeSpans([parenthesisOpen, character]),
        type: "aggregate",
    };
}
function acceptConstant(parser) {
    var _a, _b, _c, _d, _e;
    return (_e = (_d = (_c = (_b = (_a = acceptSignedFloatLit(parser)) !== null && _a !== void 0 ? _a : acceptSignedIntLit(parser)) !== null && _b !== void 0 ? _b : acceptStrLit(parser)) !== null && _c !== void 0 ? _c : acceptBoolLit(parser)) !== null && _d !== void 0 ? _d : acceptFullIdent(parser)) !== null && _e !== void 0 ? _e : acceptAggregate(parser);
}
function expectConstant(parser) {
    const constant = acceptConstant(parser);
    if (constant)
        return constant;
    throw new recursive_descent_parser_1.SyntaxError(parser, [
        identPattern,
        "-",
        "+",
        intLitPattern,
        strLitPattern,
        boolLitPattern,
    ]);
}
function acceptOptionNameSegment(parser) {
    const bracketOpen = parser.accept("(");
    const name = acceptFullIdent(parser);
    if (!name) {
        if (bracketOpen)
            throw new recursive_descent_parser_1.SyntaxError(parser, [identPattern]);
        return;
    }
    const bracketClose = parser[bracketOpen ? "expect" : "accept"](")");
    return {
        ...mergeSpans([bracketOpen, name, bracketClose]),
        type: "option-name-segment",
        bracketOpen,
        name,
        bracketClose,
    };
}
function acceptOptionName(parser) {
    const optionNameSegmentOrDots = many(parser, choice([
        acceptDot,
        acceptOptionNameSegment,
    ]));
    if (optionNameSegmentOrDots.length < 1)
        return;
    return {
        ...mergeSpans(optionNameSegmentOrDots),
        type: "option-name",
        optionNameSegmentOrDots,
    };
}
function expectOptionName(parser) {
    const optionName = acceptOptionName(parser);
    if (optionName)
        return optionName;
    throw new recursive_descent_parser_1.SyntaxError(parser, ["(", identPattern]);
}
function acceptSyntax(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "syntax");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const quoteOpen = parser.expect(/^['"]/);
    const syntax = parser.expect(/^[^'"]+/);
    const quoteClose = parser.expect(/^['"]/);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "syntax",
        keyword,
        eq,
        quoteOpen,
        syntax,
        quoteClose,
        semi,
    };
}
function acceptImport(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "import");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const weakOrPublic = parser.accept(/^weak|^public/);
    skipWsAndComments(parser);
    const strLit = expectStrLit(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "import",
        keyword,
        weakOrPublic,
        strLit,
        semi,
    };
}
function acceptPackage(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "package");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const fullIdent = expectFullIdent(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "package",
        keyword,
        fullIdent,
        semi,
    };
}
function acceptOption(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, /^option\b/);
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const optionName = expectOptionName(parser);
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const constant = expectConstant(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "option",
        keyword,
        optionName,
        eq,
        constant,
        semi,
    };
}
function acceptEmpty(parser, leadingComments, leadingDetachedComments) {
    const semi = acceptSemi(parser);
    if (!semi)
        return;
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "empty",
        semi,
    };
}
function acceptFieldOption(parser) {
    const optionName = acceptOptionName(parser);
    if (!optionName)
        return;
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const constant = expectConstant(parser);
    return {
        ...mergeSpans([optionName, constant]),
        type: "field-option",
        optionName,
        eq,
        constant,
    };
}
function acceptFieldOptions(parser) {
    const bracketOpen = parser.accept("[");
    if (!bracketOpen)
        return;
    const fieldOptionOrCommas = many(parser, choice([
        skipWsAndComments,
        acceptComma,
        acceptFieldOption,
    ]));
    const bracketClose = parser.expect("]");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "field-options",
        bracketOpen,
        fieldOptionOrCommas,
        bracketClose,
    };
}
function acceptEnumField(parser, leadingComments, leadingDetachedComments) {
    const fieldName = parser.accept(identPattern);
    if (!fieldName)
        return;
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const fieldNumber = expectSignedIntLit(parser);
    skipWsAndComments(parser);
    const fieldOptions = acceptFieldOptions(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            fieldName,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "enum-field",
        fieldName,
        eq,
        fieldNumber,
        fieldOptions,
        semi,
    };
}
function expectEnumBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptOption,
        acceptReserved,
        acceptEnumField,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "enum-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function acceptEnum(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "enum");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const enumName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const enumBody = expectEnumBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            enumBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "enum",
        keyword,
        enumName,
        enumBody,
    };
}
function acceptField(parser, leadingComments, leadingDetachedComments) {
    const loc = parser.loc;
    const fieldLabel = acceptKeyword(parser, /^required|^optional|^repeated/);
    skipWsAndComments(parser);
    const fieldType = acceptType(parser);
    if (!fieldType) {
        parser.loc = loc;
        return;
    }
    const rest = acceptComplexSequence(parser, [
        ["fieldName", (parser) => parser.expect(identPattern)],
        ["eq", (parser) => parser.expect("=")],
        ["fieldNumber", expectIntLit],
        ["fieldOptions", acceptFieldOptions],
        ["semi", expectSemi],
    ], messageBodyStatementKeywordPattern);
    const trailingComments = rest.result.semi
        ? acceptTrailingComments(parser)
        : [];
    const type = rest.partial ? "malformed-field" : "field";
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            fieldLabel,
            fieldType,
            Object.values(rest.result),
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: type,
        fieldLabel,
        fieldType,
        ...rest.result,
    };
}
function acceptOneofField(parser, leadingComments, leadingDetachedComments) {
    const fieldType = acceptType(parser);
    if (!fieldType)
        return;
    skipWsAndComments(parser);
    const fieldName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const fieldNumber = expectIntLit(parser);
    skipWsAndComments(parser);
    const fieldOptions = acceptFieldOptions(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            fieldType,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "oneof-field",
        fieldType,
        fieldName,
        eq,
        fieldNumber,
        fieldOptions,
        semi,
    };
}
function acceptMapField(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "map");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const typeBracketOpen = parser.expect("<");
    skipWsAndComments(parser);
    const keyType = expectType(parser);
    skipWsAndComments(parser);
    const typeSep = parser.expect(",");
    skipWsAndComments(parser);
    const valueType = expectType(parser);
    skipWsAndComments(parser);
    const typeBracketClose = parser.expect(">");
    skipWsAndComments(parser);
    const mapName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const fieldNumber = expectIntLit(parser);
    skipWsAndComments(parser);
    const fieldOptions = acceptFieldOptions(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "map-field",
        keyword,
        typeBracketOpen,
        keyType,
        typeSep,
        valueType,
        typeBracketClose,
        mapName,
        eq,
        fieldNumber,
        fieldOptions,
        semi,
    };
}
function expectOneofBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptOneofGroup,
        acceptOption,
        acceptOneofField,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "oneof-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function acceptOneof(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "oneof");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const oneofName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const oneofBody = expectOneofBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            oneofBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "oneof",
        keyword,
        oneofName,
        oneofBody,
    };
}
const acceptMax = acceptPatternAndThen("max", (max) => ({ type: "max", ...max }));
function acceptRange(parser) {
    var _a;
    const rangeStart = acceptIntLit(parser);
    if (!rangeStart)
        return;
    skipWsAndComments(parser);
    const to = acceptKeyword(parser, "to");
    if (!to) {
        return {
            start: rangeStart.start,
            end: rangeStart.end,
            type: "range",
            rangeStart,
        };
    }
    skipWsAndComments(parser);
    const rangeEnd = (_a = acceptIntLit(parser)) !== null && _a !== void 0 ? _a : acceptMax(parser);
    if (!rangeEnd)
        throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern, "max"]);
    return {
        ...mergeSpans([rangeStart, rangeEnd]),
        type: "range",
        rangeStart,
        to,
        rangeEnd,
    };
}
function expectRanges(parser) {
    const rangeOrCommas = many(parser, choice([
        skipWsAndComments,
        acceptComma,
        acceptRange,
    ]));
    return {
        ...mergeSpans(rangeOrCommas),
        type: "ranges",
        rangeOrCommas,
    };
}
function acceptExtensions(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "extensions");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const ranges = expectRanges(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "extensions",
        keyword,
        ranges,
        semi,
    };
}
function expectFieldNames(parser) {
    const strLitOrCommas = many(parser, choice([
        skipWsAndComments,
        acceptComma,
        acceptStrLit,
    ]));
    return {
        ...mergeSpans(strLitOrCommas),
        type: "field-names",
        strLitOrCommas,
    };
}
function acceptReserved(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "reserved");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const reserved = parser.try(intLitPattern)
        ? expectRanges(parser)
        : expectFieldNames(parser);
    skipWsAndComments(parser);
    const semi = expectSemi(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semi,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "reserved",
        keyword,
        reserved,
        semi,
    };
}
function expectExtendBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptGroup,
        acceptField,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "extend-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function acceptExtend(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "extend");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const messageType = expectType(parser);
    skipWsAndComments(parser);
    const extendBody = expectExtendBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            extendBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "extend",
        keyword,
        messageType,
        extendBody,
    };
}
function acceptGroup(parser, leadingComments, leadingDetachedComments) {
    const loc = parser.loc;
    const groupLabel = acceptKeyword(parser, /^required|^optional|^repeated/);
    if (!groupLabel) {
        parser.loc = loc;
        return;
    }
    skipWsAndComments(parser);
    const keyword = acceptKeyword(parser, "group");
    if (!keyword) {
        parser.loc = loc;
        return;
    }
    skipWsAndComments(parser);
    const groupName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const fieldNumber = expectIntLit(parser);
    skipWsAndComments(parser);
    const fieldOptions = acceptFieldOptions(parser);
    skipWsAndComments(parser);
    const messageBody = expectMessageBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            groupLabel,
            messageBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "group",
        groupLabel,
        keyword,
        groupName,
        eq,
        fieldNumber,
        fieldOptions,
        messageBody,
    };
}
function acceptOneofGroup(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "group");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const groupName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const eq = parser.expect("=");
    skipWsAndComments(parser);
    const fieldNumber = expectIntLit(parser);
    skipWsAndComments(parser);
    const messageBody = expectMessageBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            messageBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "oneof-group",
        keyword,
        groupName,
        eq,
        fieldNumber,
        messageBody,
    };
}
function expectMessageBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptGroup,
        acceptEnum,
        acceptMessage,
        acceptExtend,
        acceptExtensions,
        acceptOption,
        acceptOneof,
        acceptMapField,
        acceptReserved,
        acceptField,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "message-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function acceptMessage(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "message");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const messageName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const messageBody = expectMessageBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            messageBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "message",
        keyword,
        messageName,
        messageBody,
    };
}
function expectRpcType(parser) {
    const bracketOpen = parser.expect("(");
    skipWsAndComments(parser);
    const stream = acceptKeyword(parser, "stream");
    skipWsAndComments(parser);
    const messageType = expectType(parser);
    skipWsAndComments(parser);
    const bracketClose = parser.expect(")");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        bracketOpen,
        stream,
        messageType,
        bracketClose,
    };
}
function acceptRpc(parser, leadingComments, leadingDetachedComments) {
    var _a;
    const keyword = acceptKeyword(parser, "rpc");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const rpcName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const reqType = expectRpcType(parser);
    skipWsAndComments(parser);
    const returns = parser.expect("returns");
    skipWsAndComments(parser);
    const resType = expectRpcType(parser);
    skipWsAndComments(parser);
    const semiOrRpcBody = (_a = acceptSemi(parser)) !== null && _a !== void 0 ? _a : expectRpcBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            semiOrRpcBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "rpc",
        keyword,
        rpcName,
        reqType,
        returns,
        resType,
        semiOrRpcBody,
    };
}
function expectRpcBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptOption,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "rpc-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function expectServiceBody(parser) {
    const bracketOpen = parser.expect("{");
    const statements = acceptStatements(parser, [
        acceptOption,
        acceptRpc,
        acceptEmpty,
    ]);
    const bracketClose = parser.expect("}");
    return {
        ...mergeSpans([bracketOpen, bracketClose]),
        type: "service-body",
        bracketOpen,
        statements,
        bracketClose,
    };
}
function acceptService(parser, leadingComments, leadingDetachedComments) {
    const keyword = acceptKeyword(parser, "service");
    if (!keyword)
        return;
    skipWsAndComments(parser);
    const serviceName = parser.expect(identPattern);
    skipWsAndComments(parser);
    const serviceBody = expectServiceBody(parser);
    const trailingComments = acceptTrailingComments(parser);
    return {
        ...mergeSpans([
            leadingDetachedComments,
            leadingComments,
            keyword,
            serviceBody,
            trailingComments,
        ]),
        leadingComments,
        trailingComments,
        leadingDetachedComments,
        type: "service",
        keyword,
        serviceName,
        serviceBody,
    };
}
