"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../visitor/index");
const builder_1 = require("./builder");
const stringify_ast_frag_1 = require("./stringify-ast-frag");
function findAllReferences(schema, filePath, colRow) {
    if (!schema.files[filePath])
        return [];
    const { package: packageName, parseResult } = schema.files[filePath];
    if (!parseResult)
        return [];
    const offset = parseResult.parser.colRowToOffset(colRow);
    const resolveTypePath = (0, builder_1.getResolveTypePathFn)(schema, filePath);
    const typePath = getTypePath(packageName, parseResult, offset, resolveTypePath);
    if (!typePath)
        return [];
    const references = getTypeReferences(schema, typePath);
    const referenceNodeMap = {};
    for (const refFilePath in references) {
        const targetTypePaths = references[refFilePath];
        referenceNodeMap[refFilePath] = findReferenceNodes(schema, refFilePath, typePath, targetTypePaths);
    }
    return Object.entries(referenceNodeMap).flatMap(([filePath, referenceNodes]) => {
        return referenceNodes.map((referenceNode) => ({
            filePath,
            start: referenceNode.start,
            end: referenceNode.end,
        }));
    });
}
exports.default = findAllReferences;
function getTypePath(packageName, parseResult, offset, resolveTypePath) {
    let result;
    const stack = [packageName];
    const visitor = {
        ...index_1.visitor,
        visitSyntax() { },
        visitImport() { },
        visitOption() { },
        visitEmpty() { },
        visitPackage() { },
        visitTopLevelDef(visitor, node) {
            if (offset < node.start)
                return;
            if (offset >= node.end)
                return;
            index_1.visitor.visitTopLevelDef(visitor, node);
        },
        visitMessage(visitor, node) {
            if (offset < node.start)
                return;
            if (offset >= node.end)
                return;
            stack.push(node.messageName.text);
            if (offset >= node.messageName.start && offset < node.messageName.end) {
                result = `.${stack.join(".")}`;
            }
            index_1.visitor.visitMessageBody(visitor, node.messageBody);
            stack.pop();
        },
        visitEnum(visitor, node) {
            if (offset < node.start)
                return;
            if (offset >= node.end)
                return;
            stack.push(node.enumName.text);
            if (offset >= node.enumName.start && offset < node.enumName.end) {
                result = `.${stack.join(".")}`;
            }
            stack.pop();
        },
        visitType(visitor, node) {
            if (offset < node.start)
                return;
            if (offset >= node.end)
                return;
            result = resolveTypePath((0, stringify_ast_frag_1.stringifyType)(node), `.${stack.join(".")}`);
        },
    };
    visitor.visitProto(visitor, parseResult.ast);
    return result;
}
function getTypeReferences(schema, typePath) {
    const references = {};
    for (const [name, type] of Object.entries(schema.types)) {
        if (type.kind === "message") {
            for (const field of Object.values(type.fields)) {
                if (field.kind === "map") {
                    if (field.valueTypePath === typePath) {
                        references[type.filePath]
                            ? references[type.filePath].push(name)
                            : references[type.filePath] = [name];
                    }
                }
                else {
                    if (field.typePath === typePath) {
                        references[type.filePath]
                            ? references[type.filePath].push(name)
                            : references[type.filePath] = [name];
                    }
                }
            }
        }
    }
    return references;
}
function findReferenceNodes(schema, filePath, typePath, targetTypePaths) {
    const file = schema.files[filePath];
    if (!file.parseResult)
        return [];
    const typeNodes = [];
    const stack = [file.package];
    const resolveTypePath = (0, builder_1.getResolveTypePathFn)(schema, filePath);
    const visitor = {
        ...index_1.visitor,
        visitSyntax() { },
        visitImport() { },
        visitOption() { },
        visitEmpty() { },
        visitPackage() { },
        visitMessage(visitor, node) {
            stack.push(node.messageName.text);
            index_1.visitor.visitMessageBody(visitor, node.messageBody);
            stack.pop();
        },
        visitEnum(visitor, node) {
            stack.push(node.enumName.text);
            index_1.visitor.visitEnumBody(visitor, node.enumBody);
            stack.pop();
        },
        visitType(visitor, node) {
            const scope = `.${stack.join(".")}`;
            if (targetTypePaths.includes(scope)) {
                if (resolveTypePath((0, stringify_ast_frag_1.stringifyType)(node), scope) === typePath) {
                    typeNodes.push(node);
                }
            }
        },
    };
    visitor.visitProto(visitor, file.parseResult.ast);
    return typeNodes.map((typeNode) => {
        const { start: startOffset, end: endOffset } = typeNode;
        if (!file.parseResult)
            throw new Error("parseResult cannot be undefined");
        const start = file.parseResult.parser.offsetToColRow(startOffset);
        const end = file.parseResult.parser.offsetToColRow(endOffset);
        return { start, end };
    });
}
