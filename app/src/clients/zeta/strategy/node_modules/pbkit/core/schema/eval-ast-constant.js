"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalStrLit = exports.evalSignedFloatLit = exports.evalFloatLit = exports.evalSignedIntLit = exports.evalIntLit = exports.evalBoolLit = exports.evalConstant = void 0;
const stringify_ast_frag_1 = require("./stringify-ast-frag");
function evalConstant(constant) {
    switch (constant.type) {
        case "aggregate":
            return "";
        case "bool-lit":
            return evalBoolLit(constant.text);
        case "full-ident":
            return (0, stringify_ast_frag_1.stringifyFullIdent)(constant);
        case "signed-float-lit":
            return evalSignedFloatLit(constant);
        case "signed-int-lit":
            return evalSignedIntLit(constant);
        case "str-lit":
            return evalStrLit(constant);
    }
}
exports.evalConstant = evalConstant;
function evalBoolLit(text) {
    if (text === "true")
        return true;
    return false;
}
exports.evalBoolLit = evalBoolLit;
function evalIntLit(intLit) {
    const text = intLit.text;
    if (text.startsWith("0x"))
        return parseInt(text, 16);
    if (text.startsWith("0"))
        return parseInt(text, 8);
    return parseInt(text, 10);
}
exports.evalIntLit = evalIntLit;
function evalSignedIntLit(signedIntLit) {
    var _a;
    const intLit = signedIntLit.value;
    if (((_a = signedIntLit.sign) === null || _a === void 0 ? void 0 : _a.text) === "-")
        return -evalIntLit(intLit);
    return evalIntLit(intLit);
}
exports.evalSignedIntLit = evalSignedIntLit;
function evalFloatLit(floatLit) {
    const text = floatLit.text;
    if (text === "inf")
        return Infinity;
    if (text === "nan")
        return NaN;
    return parseFloat(text);
}
exports.evalFloatLit = evalFloatLit;
function evalSignedFloatLit(signedFloatLit) {
    var _a;
    const floatLit = signedFloatLit.value;
    if (((_a = signedFloatLit.sign) === null || _a === void 0 ? void 0 : _a.text) === "-")
        return -evalFloatLit(floatLit);
    return evalFloatLit(floatLit);
}
exports.evalSignedFloatLit = evalSignedFloatLit;
function evalStrLit(strLit) {
    return strLit.tokens.map((token) => evalStrLitFragment(token.text)).join("");
}
exports.evalStrLit = evalStrLit;
function evalStrLitFragment(text) {
    return text
        .slice(1, -1)
        .replace(/(?:\\x([0-9a-f]{2})|\\([0-7]{3})|\\([0abfnrtv\\'"]))/i, (input, hex, octal, char) => {
        if (hex)
            return String.fromCodePoint(parseInt(hex, 16));
        if (octal)
            return String.fromCharCode(parseInt(octal, 8) % 0x100);
        if (char)
            return charMap[char.toLowerCase()];
        return input;
    });
}
const charMap = {
    "0": "\x00",
    "a": "\x07",
    "b": "\x08",
    "f": "\x0C",
    "n": "\x0A",
    "r": "\x0D",
    "t": "\x09",
    "v": "\x0B",
    "\\": "\x5C",
    "'": "\x27",
    '"': "\x22",
};
