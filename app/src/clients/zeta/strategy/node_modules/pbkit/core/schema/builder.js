"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResolveTypePathFn = exports.merge = exports.gather = exports.connect = exports.extract = exports.build = void 0;
const proto_1 = require("../parser/proto");
const array_1 = require("../runtime/array");
const ast_util_1 = require("./ast-util");
const comment_1 = require("./comment");
const eval_ast_constant_1 = require("./eval-ast-constant");
const scalar_1 = require("../runtime/scalar");
const stringify_ast_frag_1 = require("./stringify-ast-frag");
async function build(config) {
    return connect(await extract(gather(config)));
}
exports.build = build;
async function extract(files) {
    const result = {
        files: {},
        types: {},
        extends: {},
        services: {},
    };
    for await (const { filePath, parseResult, file } of files) {
        result.files[filePath] = file;
        const typePath = file.package ? "." + file.package : "";
        const statements = parseResult.ast.statements;
        const services = iterServices(statements, typePath, filePath);
        for (const [typePath, service] of services) {
            file.servicePaths.push(typePath);
            if (!(typePath in result.services))
                result.services[typePath] = service;
        }
        const types = iterTypes(statements, typePath, filePath);
        for (const [typePath, type] of types) {
            file.typePaths.push(typePath);
            if (!(typePath in result.types))
                result.types[typePath] = type;
        }
        // TODO: extends
    }
    return result;
}
exports.extract = extract;
function connect(schema) {
    const importPathToFilePath = {};
    for (const [filePath, { importPath }] of Object.entries(schema.files)) {
        if (importPath in importPathToFilePath)
            continue;
        importPathToFilePath[importPath] = filePath;
    }
    for (const file of Object.values(schema.files)) {
        for (const entry of file.imports) {
            if (entry.importPath in importPathToFilePath) {
                entry.filePath = importPathToFilePath[entry.importPath];
            }
        }
    }
    for (const [filePath, file] of Object.entries(schema.files)) {
        const resolveTypePath = getResolveTypePathFn(schema, filePath);
        for (const typePath of file.typePaths) {
            const type = schema.types[typePath];
            if (type.kind === "enum")
                continue;
            for (const field of Object.values(type.fields)) {
                if (field.kind === "map") {
                    const fieldKeyTypePath = resolveTypePath(field.keyType, typePath);
                    const fieldValueTypePath = resolveTypePath(field.valueType, typePath);
                    if (fieldKeyTypePath)
                        field.keyTypePath = fieldKeyTypePath;
                    if (fieldValueTypePath)
                        field.valueTypePath = fieldValueTypePath;
                }
                else {
                    const fieldTypePath = resolveTypePath(field.type, typePath);
                    if (fieldTypePath)
                        field.typePath = fieldTypePath;
                }
            }
        }
        for (const servicePath of file.servicePaths) {
            const service = schema.services[servicePath];
            for (const rpc of Object.values(service.rpcs)) {
                const reqTypePath = resolveTypePath(rpc.reqType.type, servicePath);
                const resTypePath = resolveTypePath(rpc.resType.type, servicePath);
                if (reqTypePath)
                    rpc.reqType.typePath = reqTypePath;
                if (resTypePath)
                    rpc.resType.typePath = resTypePath;
            }
        }
    }
    return schema;
}
exports.connect = connect;
async function* gather({ files, loader }) {
    const queue = [...files];
    const visited = {};
    const loaded = {};
    while (queue.length) {
        const importPath = queue.pop();
        if (visited[importPath])
            continue;
        visited[importPath] = true;
        const loadResult = await loader.load(importPath);
        if (!loadResult)
            continue;
        if (loaded[loadResult.absolutePath])
            continue;
        loaded[loadResult.absolutePath] = true;
        const parseResult = (0, proto_1.parse)(loadResult.data);
        const statements = parseResult.ast.statements;
        const file = {
            parseResult,
            importPath,
            syntax: getSyntax(statements),
            package: getPackage(statements),
            imports: getImports(statements),
            options: getOptions(statements),
            typePaths: [],
            servicePaths: [],
        };
        yield { filePath: loadResult.absolutePath, parseResult, file };
        queue.push(...file.imports.map(({ importPath }) => importPath));
    }
}
exports.gather = gather;
function merge(older, newer) {
    const result = {
        files: { ...older.files, ...newer.files },
        types: { ...older.types, ...newer.types },
        extends: { ...older.extends, ...newer.extends },
        services: { ...older.services, ...newer.services },
    };
    { // types
        const olderTypePaths = Object.keys(older.types);
        const newerTypePaths = Object.keys(newer.types);
        for (const typePath of intersect(olderTypePaths, newerTypePaths)) {
            const olderType = older.types[typePath];
            const newerType = newer.types[typePath];
            result.types[typePath] = mergeType(olderType, newerType);
        }
    }
    { // extends
        const olderTypePaths = Object.keys(older.extends);
        const newerTypePaths = Object.keys(newer.extends);
        for (const typePath of intersect(olderTypePaths, newerTypePaths)) {
            const olderExtends = older.extends[typePath];
            const newerExtends = newer.extends[typePath];
            result.extends[typePath] = mergeExtends(olderExtends, newerExtends);
        }
    }
    { // services
        const olderServicePaths = Object.keys(older.services);
        const newerServicePaths = Object.keys(newer.services);
        for (const servicePath of intersect(olderServicePaths, newerServicePaths)) {
            const olderService = older.services[servicePath];
            const newerService = newer.services[servicePath];
            result.services[servicePath] = mergeService(olderService, newerService);
        }
    }
    return result;
}
exports.merge = merge;
function mergeType(older, newer) {
    if (older.kind !== newer.kind)
        return newer;
    if (older.kind === "message") {
        const _newer = newer;
        const result = { ..._newer };
        return result; // TODO
    }
    else {
        const _newer = newer;
        const result = { ..._newer };
        result.fields = { ...older.fields, ..._newer.fields };
        return result;
    }
}
function mergeExtends(older, newer) {
    return newer; // TODO
}
function mergeService(older, newer) {
    return newer; // TODO
}
function intersect(a, b) {
    return a.filter((x) => b.includes(x));
}
function getSyntax(statements) {
    const syntaxStatement = (0, ast_util_1.findNodeByType)(statements, "syntax");
    const syntax = syntaxStatement === null || syntaxStatement === void 0 ? void 0 : syntaxStatement.syntax.text;
    return syntax === "proto3" ? "proto3" : "proto2";
}
function getPackage(statements) {
    const packageStatement = (0, ast_util_1.findNodeByType)(statements, "package");
    if (!packageStatement)
        return "";
    return (0, stringify_ast_frag_1.stringifyFullIdent)(packageStatement.fullIdent);
}
function getImports(statements) {
    const importStatements = (0, ast_util_1.filterNodesByType)(statements, "import");
    return importStatements.map((statement) => {
        var _a;
        const kind = (((_a = statement.weakOrPublic) === null || _a === void 0 ? void 0 : _a.text) || "");
        const importPath = (0, eval_ast_constant_1.evalStrLit)(statement.strLit);
        return {
            kind,
            importPath,
        };
    });
}
function getOptions(nodes) {
    if (!nodes)
        return {};
    const optionStatements = (0, ast_util_1.filterNodesByTypes)(nodes, [
        "option",
        "field-option",
    ]);
    const result = {};
    for (const statement of optionStatements) {
        const optionName = (0, stringify_ast_frag_1.stringifyOptionName)(statement.optionName);
        const optionValue = (0, eval_ast_constant_1.evalConstant)(statement.constant);
        result[optionName] = optionValue;
    }
    return result;
}
function* iterServices(statements, typePath, filePath) {
    const serviceStatements = (0, ast_util_1.filterNodesByType)(statements, "service");
    for (const statement of serviceStatements) {
        const serviceTypePath = typePath + "." + statement.serviceName.text;
        const service = {
            filePath,
            options: getOptions(statement.serviceBody.statements),
            description: getDescription(statement),
            rpcs: getRpcs(statement.serviceBody.statements),
        };
        yield [serviceTypePath, service];
    }
}
function getRpcs(statements) {
    const rpcStatements = (0, ast_util_1.filterNodesByType)(statements, "rpc");
    const rpcs = {};
    for (const statement of rpcStatements) {
        const options = statement.semiOrRpcBody.type === "rpc-body"
            ? getOptions(statement.semiOrRpcBody.statements)
            : {};
        rpcs[statement.rpcName.text] = {
            options,
            description: getDescription(statement),
            reqType: getRpcType(statement.reqType),
            resType: getRpcType(statement.resType),
        };
    }
    return rpcs;
}
function getRpcType(rpcType) {
    return {
        stream: !!rpcType.stream,
        type: (0, stringify_ast_frag_1.stringifyType)(rpcType.messageType),
    };
}
function* iterTypes(statements, typePath, filePath) {
    for (const statement of statements) {
        if (statement.type === "enum") {
            yield getEnum(statement, typePath, filePath);
        }
        else if (statement.type === "message") {
            const message = getMessage(statement, typePath, filePath);
            yield message;
            const messageBodyStatement = statement.messageBody.statements;
            yield* iterTypes(messageBodyStatement, message[0], filePath);
        }
    }
}
function getMessage(statement, typePath, filePath) {
    const messageTypePath = typePath + "." + statement.messageName.text;
    const statements = statement.messageBody.statements;
    const message = {
        kind: "message",
        filePath,
        description: getDescription(statement),
        ...getMessageBody(statements),
    };
    return [messageTypePath, message];
}
function getMessageBody(statements) {
    const fields = {};
    for (const [fieldNumber, field] of iterMessageFields(statements)) {
        fields[fieldNumber] = field;
    }
    const groups = {};
    for (const groupStatement of (0, ast_util_1.filterNodesByType)(statements, "group")) {
        const groupName = groupStatement.groupName.text;
        groups[groupName] = getGroup(groupStatement);
    }
    return {
        options: getOptions(statements),
        fields,
        groups,
        reservedFieldNumberRanges: [],
        reservedFieldNames: [],
        extensions: [], // TODO
    };
}
function* iterMessageFields(statements) {
    var _a, _b;
    for (const statement of statements) {
        if (statement.type === "field") {
            const fieldNumber = (0, eval_ast_constant_1.evalIntLit)(statement.fieldNumber);
            const fieldBase = {
                description: getDescription(statement),
                name: statement.fieldName.text,
                options: getOptions((_a = statement.fieldOptions) === null || _a === void 0 ? void 0 : _a.fieldOptionOrCommas),
                type: (0, stringify_ast_frag_1.stringifyType)(statement.fieldType),
            };
            if (!statement.fieldLabel) {
                yield [fieldNumber, { kind: "normal", ...fieldBase }];
            }
            else {
                const kind = statement.fieldLabel.text;
                if (kind === "required" ||
                    kind === "optional" ||
                    kind === "repeated") {
                    yield [fieldNumber, { kind, ...fieldBase }];
                }
            }
        }
        else if (statement.type === "oneof") {
            yield* iterOneofFields(statement.oneofBody.statements, statement.oneofName.text);
        }
        else if (statement.type === "map-field") {
            yield [(0, eval_ast_constant_1.evalIntLit)(statement.fieldNumber), {
                    kind: "map",
                    description: getDescription(statement),
                    name: statement.mapName.text,
                    options: getOptions((_b = statement.fieldOptions) === null || _b === void 0 ? void 0 : _b.fieldOptionOrCommas),
                    keyType: (0, stringify_ast_frag_1.stringifyType)(statement.keyType),
                    valueType: (0, stringify_ast_frag_1.stringifyType)(statement.valueType),
                }];
        }
    }
}
function* iterOneofFields(statements, oneof) {
    var _a;
    const oneofStatements = (0, ast_util_1.filterNodesByType)(statements, "oneof-field");
    for (const statement of oneofStatements) {
        const fieldNumber = (0, eval_ast_constant_1.evalIntLit)(statement.fieldNumber);
        yield [fieldNumber, {
                kind: "oneof",
                description: getDescription(statement),
                name: statement.fieldName.text,
                options: getOptions((_a = statement.fieldOptions) === null || _a === void 0 ? void 0 : _a.fieldOptionOrCommas),
                type: (0, stringify_ast_frag_1.stringifyType)(statement.fieldType),
                oneof,
            }];
    }
}
function getGroup(statement) {
    const statements = statement.messageBody.statements;
    const fields = {};
    for (const [fieldNumber, field] of iterMessageFields(statements)) {
        fields[fieldNumber] = field;
    }
    return {
        kind: statement.groupLabel.text,
        description: getDescription(statement),
        fieldNumber: (0, eval_ast_constant_1.evalIntLit)(statement.fieldNumber),
        ...getMessageBody(statements),
    };
}
function getEnum(statement, typePath, filePath) {
    const enumTypePath = typePath + "." + statement.enumName.text;
    const _enum = {
        kind: "enum",
        filePath,
        options: getOptions(statement.enumBody.statements),
        description: getDescription(statement),
        fields: getEnumFields(statement.enumBody.statements),
    };
    return [enumTypePath, _enum];
}
function getEnumFields(statements) {
    var _a;
    const fields = {};
    const enumFieldStatements = (0, ast_util_1.filterNodesByType)(statements, "enum-field");
    for (const statement of enumFieldStatements) {
        const fieldNumber = (0, eval_ast_constant_1.evalSignedIntLit)(statement.fieldNumber);
        fields[fieldNumber] = {
            description: getDescription(statement),
            name: statement.fieldName.text,
            options: getOptions((_a = statement.fieldOptions) === null || _a === void 0 ? void 0 : _a.fieldOptionOrCommas),
        };
    }
    return fields;
}
function getDescription(statement) {
    return {
        leading: unwrapComments(statement.leadingComments),
        trailing: unwrapComments(statement.trailingComments),
        leadingDetached: unwrapComments(statement.leadingDetachedComments),
    };
    function unwrapComments(commentGroups) {
        return commentGroups.map((commentGroup) => commentGroup.comments.map((comment) => (0, comment_1.unwrap)(comment.text)).join("\n"));
    }
}
function getResolveTypePathFn(schema, filePath) {
    const visibleTypePaths = (0, array_1.toPojoSet)(getVisibleTypePaths(schema, filePath));
    return function resolveTypePath(type, scope) {
        if (type in scalarValueTypeSet)
            return "." + type;
        if (type.startsWith("."))
            return visibleTypePaths[type];
        let currentScope = scope;
        while (true) {
            const typePath = currentScope + "." + type;
            if (typePath in visibleTypePaths)
                return typePath;
            const cut = currentScope.lastIndexOf(".");
            if (cut < 0)
                return undefined;
            currentScope = currentScope.slice(0, cut);
        }
    };
}
exports.getResolveTypePathFn = getResolveTypePathFn;
const scalarValueTypeSet = (0, array_1.toPojoSet)(scalar_1.scalarValueTypes);
function getVisibleTypePaths(schema, filePath) {
    const file = schema.files[filePath];
    if (!file)
        return [];
    return [
        ...file.typePaths,
        ...file.imports.map((entry) => entry.filePath ? getExportedTypePaths(schema, entry.filePath) : []).flat(1),
    ];
}
function getExportedTypePaths(schema, filePath) {
    const result = [];
    const done = {};
    const queue = [filePath];
    while (queue.length) {
        const filePath = queue.pop();
        if (done[filePath])
            continue;
        done[filePath] = true;
        const file = schema.files[filePath];
        if (!file)
            continue;
        result.push(...file.typePaths);
        for (const entry of file.imports) {
            if (entry.kind !== "public")
                continue;
            if (!entry.filePath)
                continue;
            queue.push(entry.filePath);
        }
    }
    return result;
}
