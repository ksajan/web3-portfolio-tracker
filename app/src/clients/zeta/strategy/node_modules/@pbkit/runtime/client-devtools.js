"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapRpcClientImpl = exports.getDevtoolsConfig = exports.devtoolsKey = void 0;
const event_emitter_1 = require("./async/event-emitter");
exports.devtoolsKey = "@pbkit/devtools";
function getDevtoolsConfig() {
    const global = globalThis;
    if (!global[exports.devtoolsKey]) {
        const devtoolsConfig = createDevtoolsConfig();
        return global[exports.devtoolsKey] = devtoolsConfig;
    }
    else if (Array.isArray(global[exports.devtoolsKey])) {
        const devtoolsConfig = createDevtoolsConfig();
        for (const fn of global[exports.devtoolsKey]) {
            if (typeof fn !== "function")
                continue;
            fn(devtoolsConfig);
        }
        return global[exports.devtoolsKey] = devtoolsConfig;
    }
    else {
        return global[exports.devtoolsKey];
    }
}
exports.getDevtoolsConfig = getDevtoolsConfig;
function createDevtoolsConfig() {
    const devtoolsConfig = {
        configId: String(Date.now()),
        requestIdCounter: 0,
        ...(0, event_emitter_1.createEventEmitter)(),
    };
    return devtoolsConfig;
}
function wrapRpcClientImpl(config) {
    return function devtoolsRpcClientImpl(methodDescriptor) {
        const { rpcClientImpl, devtoolsConfig, tags } = config;
        const rpcMethodImpl = rpcClientImpl(methodDescriptor);
        return function devtoolsRpcMethodImpl(req, metadata) {
            const configId = devtoolsConfig.configId;
            const requestId = devtoolsConfig.requestIdCounter++;
            devtoolsConfig.emit("request", {
                configId,
                requestId,
                servicePath: methodDescriptor.service.serviceName,
                rpcName: methodDescriptor.methodName,
                metadataJson: toJson(metadata),
                tags,
            });
            const rpcMethodResult = rpcMethodImpl(mapAsyncGenerator(req, (payload) => {
                devtoolsConfig.emit("request-payload", {
                    configId,
                    requestId,
                    payloadJson: methodDescriptor.requestType.serializeJson(payload),
                    payloadProto: methodDescriptor.requestType.serializeBinary(payload),
                });
                return payload;
            }, (error) => {
                devtoolsConfig.emit("request-error", {
                    configId,
                    requestId,
                    errorMessage: getErrorMessage(error),
                });
            }), metadata);
            const resAsyncGenerator = mapAsyncGenerator(rpcMethodResult[0], (payload) => {
                devtoolsConfig.emit("response-payload", {
                    configId,
                    requestId,
                    payloadJson: methodDescriptor.responseType.serializeJson(payload),
                    payloadProto: methodDescriptor.responseType.serializeBinary(payload),
                });
                return payload;
            }, (error) => {
                devtoolsConfig.emit("response-error", {
                    configId,
                    requestId,
                    errorMessage: getErrorMessage(error),
                });
            });
            const headerPromise = rpcMethodResult[1].then((header) => {
                devtoolsConfig.emit("response", {
                    configId,
                    requestId,
                    headerJson: toJson(header),
                });
                return header;
            });
            const trailerPromise = rpcMethodResult[2].then((trailer) => {
                devtoolsConfig.emit("response-trailer", {
                    configId,
                    requestId,
                    trailerJson: toJson(trailer),
                });
                return trailer;
            });
            return [resAsyncGenerator, headerPromise, trailerPromise];
        };
    };
}
exports.wrapRpcClientImpl = wrapRpcClientImpl;
function toJson(value) {
    if ((!value) || (typeof value !== "object"))
        return "{}";
    return JSON.stringify(value);
}
async function* mapAsyncGenerator(asyncGenerator, fn, catchFn) {
    try {
        for await (const value of asyncGenerator) {
            yield await fn(value);
        }
    }
    catch (error) {
        catchFn(error);
        throw error;
    }
}
function getErrorMessage(error) {
    if (error instanceof Error)
        return error.stack || error.message;
    return String(error);
}
